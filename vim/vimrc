" -----
" Setup
" -----
scriptencoding utf-8

if has('win32')
	let g:vimfiles_path = '~/vimfiles'
else
	let g:vimfiles_path = '~/.vim'
endif

let g:bundle_path = util#path_join(g:vimfiles_path, 'bundle')

if has('vim_starting')
	set nocompatible
	filetype off
	exec 'set runtimepath+=' . expand(util#path_join(g:bundle_path, 'neobundle'))
endif

let g:neobundle#enable_name_conversion = 1
call neobundle#begin(g:bundle_path)

NeoBundleFetch 'Shougo/neobundle.vim'

NeoBundle 'Shougo/vimproc.vim', {
	\   'build': {
	\     'windows': 'tools\\update-dll-mingw',
	\     'cygwin': 'make -f make_cygwin.mak',
	\     'mac': 'make -f make_mac.mak',
	\     'unix': 'make -f make_unix.mak'
	\   }
	\ }

" appearance
NeoBundle 'chriskempson/base16-vim'
NeoBundle 'itchyny/lightline.vim'

" vcs integration
NeoBundle 'mhinz/vim-signify'

" languages
NeoBundle 'derekwyatt/vim-scala'
NeoBundle 'leshill/vim-json'
NeoBundle 'tikhomirov/vim-glsl'
NeoBundle 'tpope/vim-markdown'

" unite
NeoBundle 'Shougo/unite.vim', {'depends': 'Shougo/vimproc.vim'}
NeoBundle 'Shougo/unite-outline', {'depends': 'Shougo/unite.vim'}
NeoBundle 'Shougo/unite-session', {'depends': 'Shougo/unite.vim'}

" other
NeoBundle 'matchit.zip'
NeoBundleLazy 'derekwyatt/vim-fswitch', {'autoload': {'filetypes': ['c', 'cpp']}}
NeoBundle 'kana/vim-textobj-entire', {'depends': 'kana/vim-textobj-user'}
NeoBundle 'Lokaltog/vim-easymotion', {'depends': 'tpope/vim-repeat'}
NeoBundle 'nelstrom/vim-visual-star-search'
NeoBundle 'Raimondi/delimitMate'
NeoBundle 'scrooloose/syntastic'
NeoBundle 'SirVer/ultisnips'
NeoBundle 'tommcdo/vim-exchange'
NeoBundle 'tpope/vim-abolish', {'depends': 'tpope/vim-repeat'}
NeoBundle 'tpope/vim-commentary', {'depends': 'tpope/vim-repeat'}
NeoBundle 'tpope/vim-endwise'
NeoBundle 'tpope/vim-surround', {'depends': 'tpope/vim-repeat'}
NeoBundle 'tpope/vim-unimpaired', {'depends': 'tpope/vim-repeat'}
NeoBundle 'Valloric/ListToggle'
NeoBundle 'Valloric/YouCompleteMe'
NeoBundle 'xolox/vim-easytags', {'depends': 'xolox/vim-misc', 'external_commands': 'ctags'}

call neobundle#end()

if has('autocmd')
	augroup vimrc
		autocmd!
	augroup END
endif

" --------
" Settings
" --------
call util#mkdir_if_none(util#path_join(g:vimfiles_path, 'undo'))

filetype plugin indent on

set omnifunc=syntaxcomplete#Complete
set completeopt=menu,menuone,longest

let mapleader = "\\"
let maplocalleader = "\\"
map <space> <leader>

set history=1000
set undoreload=1000
set undodir=$HOME/.vim/undo
set undofile
set nobackup
set noswapfile

set pastetoggle=<F2>

if has('mouse')
	set mouse=a
endif

if has('unnamedplus')
	set clipboard=unnamedplus,unnamed
else
	set clipboard+=unnamed
endif

set backspace=indent,eol,start

set autoread
set hidden

set ttimeout
set ttimeoutlen=100

set noerrorbells novisualbell t_vb=
set shortmess=atsoOI
set showcmd
set scrolloff=3
set ttyfast
set lazyredraw
set t_ut=
set noshowmode
set laststatus=2
set number
set norelativenumber

if has('multi_byte')
	set listchars=tab:▸\ ,eol:¬,extends:»,precedes:«
	set showbreak=…
else
	set listchars=tab:>\ ,eol:$,extends:>,precedes:<
	set showbreak=~
endif

set list

set wildmenu
set wildmode=longest:full,full
set wildignore+=.hg,.git,.svn                    " version control files
set wildignore+=*.aux,*.out,*.toc                " LaTeX build files
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.class                          " java compiled objects
set wildignore+=*.luac                           " lua byte code
set wildignore+=*.pyc                            " python byte code
set wildignore+=*.sw                             " vim swap files
set wildignore+=*.DS_Store                       " OSX something

set tabstop=4
set shiftwidth=4
set softtabstop=4
set noexpandtab
set shiftround

set wrap
set textwidth=79
set formatoptions=cqrn1j
set smartindent

set magic
set ignorecase
set smartcase
set incsearch
set hlsearch
set gdefault

if has('autocmd')
	augroup vimrc
		" automatically resize splits on window resize
		autocmd VimResized * :wincmd =
		" restore line position
		autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
	augroup END
endif

" -----
" Theme
" -----
syntax on

set cursorline
let g:base16colorspace=256
set background=dark
colorscheme base16-monokai

"
" lightline
"
let g:lightline = {
	\   'colorscheme': 'wombat',
	\   'mode_map': {
	\     'n':      'N',
	\     'i':      'I',
	\     'R':      'R',
	\     'v':      'V',
	\     'V':      'V',
	\     "\<c-v>": 'V',
	\     'c':      'C',
	\     's':      'S',
	\     'S':      'S',
	\     "\<c-s>": 'S',
	\     '?':      '?',
	\   },
	\   'separator': {
	\     'left': '',
	\     'right': ''
	\   },
	\   'component_function': {
	\     'fileencoding': 'LightlineComponent_fileencoding',
	\     'fileformat':   'LightlineComponent_fileformat',
	\     'filename':     'LightlineComponent_filename',
	\     'filetype':     'LightlineComponent_filetype',
	\     'vcs':          'LightlineComponent_vcs'
	\   },
	\   'component_expand': {
	\     'loclist': 'LightlineComponent_loclist'
	\   },
	\   'component_type': {
	\     'loclist': 'error',
	\   },
	\   'active': {
	\     'left':  [['mode', 'paste'],
	\               ['vcs', 'filename', 'loclist']],
	\     'right': [['lineinfo'],
	\               ['percent'],
	\               ['fileformat', 'fileencoding', 'filetype']]
	\   },
	\   'tabline': {
	\     'left':  [['tabs']],
	\     'right': [[]]
	\   }
	\ }

if has('multi_byte')
	let g:lightline.subseparator = {'left': '›', 'right': '‹'}
else
	let g:lightline.subseparator = {'left': '>', 'right': '<'}
endif

let g:lightline_hunks_symbols = ['+', '~', '-']

function! LightlineComponent_fileencoding()
	if winwidth(0) > 70
		return strlen(&fenc) ? &fenc : ''
	endif
	return ''
endfunction

function! LightlineComponent_fileformat()
	if winwidth(0) > 70
		return strlen(&fileformat) ? &fileformat : ''
	endif
	return ''
endfunction

function! LightlineComponent_filename()
	let l:filename = expand('%:t')
	let l:filename = len(l:filename) ? l:filename : ''
	let l:readonly = &readonly ? '!! ' : ''
	let l:modified = &modified ? '+' : ''
	let l:modified = (len(l:modified) && len(l:filename) ? ' ' : '') . l:modified
	return l:readonly . l:filename . l:modified
endfunction

function! LightlineComponent_filetype()
	if winwidth(0) > 70
		return strlen(&filetype) ? &filetype : ''
	endif
	return ''
endfunction

function! LightlineComponent_vcs()
	if g:loaded_signify == 1
		" build string of hunks
		let l:hunks = sy#repo#get_stats()
		let l:hunks_str = ''
		for i in [0, 1, 2]
			if l:hunks[i] > 0
				let l:hunks_str .= printf('%s%s', g:lightline_hunks_symbols[i], l:hunks[i])
				if i < 2 && l:hunks[i+1] > 0
					let l:hunks_str .= ' '
				endif
			endif
		endfor
		return l:hunks_str
	endif
	return ''
endfunction

function! LightlineComponent_loclist()
	" get error/warning count
	let l:loclist = getloclist(0)
	let l:num_errors = 0
	let l:num_warns = 0
	for i in l:loclist
		if i.type == 'E'
			let l:num_errors += 1
		else
			let l:num_warns += 1
		endif
	endfor
	" generate string
	let l:loclist_str = ''
	if l:num_errors > 0
		let l:loclist_str .= 'E: ' . l:num_errors
	endif
	if l:num_warns > 0
		if l:num_errors > 0
			let l:loclist_str .= ' '
		endif
		let l:loclist_str .= 'W: ' . l:num_warns
	endif
	return l:loclist_str
endfunction

" -------
" Plugins
" -------
"
" netrw (disable)
"
let g:loaded_netrw = 1
let g:loaded_netrwPlugin = 1

"
" DelimitMate
"
let delimitMate_matchpairs = "(:),[:],{:}"
let delimitMate_quotes = "\" ' `"
let delimitMate_expand_cr = 1
let delimitMate_jump_expansion = 1

if has('autocmd')
	augroup vimrc
		" filetype specific pairs
		" filetype specific quotes
		autocmd FileType vim let b:delimitMate_quotes = "'"
		" filetype specific nesting
		autocmd FileType python let b:delimitMate_nesting_quotes = ['"']
	augroup END
endif

"
" EasyMotion
"
let bundle = neobundle#get('easymotion')
function! bundle.hooks.on_source(bundle)
	let g:EasyMotion_enter_jump_first = 1
	let g:EasyMotion_smartcase = 1
	let g:EasyMotion_use_smartsign_us = 1
	let g:EasyMotion_startofline = 0
	let g:EasyMotion_move_highlight = 0
	map em <plug>(easymotion-prefix)
	" replace default search
	map / <plug>(easymotion-sn)
	omap / <plug>(easymotion-tn)
	map n <plug>(easymotion-next)
	map N <plug>(easymotion-prev)
endfunction

"
" EasyTags
"
let bundle = neobundle#get('easytags')
function! bundle.hooks.on_source(bundle)
	set tags=./tags;$HOME
	let g:easytags_dynamic_files = 1
	let g:easytags_by_filetype = util#path_join(g:vimfiles_path, 'tags')
	call util#mkdir_if_none(g:easytags_by_filetype)
	let g:easytags_updatetime_warn = 0
	let g:easytags_always_enableds = 1
endfunction

"
" FSwitch
"
let bundle = neobundle#get('fswitch')
function! bundle.hooks.on_source(bundle)
	if has('autocmd')
		augroup vimrc
			autocmd FileType c,cpp nmap <buffer> <leader>af :FSHere<cr>
			autocmd FileType c,cpp nmap <buffer> <leader>al :FSRight<cr>
			autocmd FileType c,cpp nmap <buffer> <leader>aL :FSSplitRight<cr>
			autocmd FileType c,cpp nmap <buffer> <leader>ah :FSLeft<cr>
			autocmd FileType c,cpp nmap <buffer> <leader>aH :FSSplitLeft<cr>
			autocmd FileType c,cpp nmap <buffer> <leader>ak :FSAbove<cr>
			autocmd FileType c,cpp nmap <buffer> <leader>aK :FSSplitAbove<cr>
			autocmd FileType c,cpp nmap <buffer> <leader>aj :FSBelow<cr>
			autocmd FileType c,cpp nmap <buffer> <leader>aJ :FSSplitBelow<cr>
		augroup END
	endif
endfunction

"
" ListToggle
"
let bundle = neobundle#get('ListToggle')
function! bundle.hooks.on_source(bundle)
	let g:lt_location_list_toggle_map = '<leader>l'
	let g:lt_quickfix_list_toggle_map = '<leader>q'
	let g:lt_height = 10
endfunction

"
" Scala
"
let bundle = neobundle#get('scala')
function! bundle.hooks.on_source(bundle)
	let g:scala_sort_across_groups = 1
endfunction

"
" Signify
"
let bundle = neobundle#get('signify')
function! bundle.hooks.on_source(bundle)
	let g:signify_sign_overwrite = 0
	let g:signify_sign_add = '+'
	let g:signify_sign_change = '~'
	let g:signify_sign_delete = '-'
	let g:signify_sign_delete_first_line = '^'
endfunction

"
" Syntastic
"
let bundle = neobundle#get('syntastic')
function! bundle.hooks.on_source(bundle)
	let g:syntastic_check_on_wq = 0
	let g:syntastic_always_populate_loc_list = 1
	let g:syntastic_auto_loc_list = 1
	let g:syntastic_check_on_open = 1
	let g:syntastic_echo_current_error = 1
	let g:syntastic_enable_signs = 0
	let g:syntastic_enable_highlighting = 0
	let g:syntastic_enable_balloons = 0
	if executable('flake8')
		let g:syntastic_python_checkers = ['flake8']
	endif
endfunction

"
" UltiSnips
"
let g:UltiSnipsEditSplit = 'vertical'
let g:UltiSnipsSnippetDirectories = ['snips']
let g:UltiSnipsExpandTrigger = '<c-j>'
let g:UltiSnipsJumpForwardTrigger = '<c-j>'
let g:UltiSnipsJumpBackwardTrigger = '<c-k>'

"
" Unimpaired
"
let bundle = neobundle#get('unimpaired')
function! bundle.hooks.on_source(bundle)
	nmap mk [e
	nmap mj ]e
	vmap mk [egv
	vmap mj ]egv
endfunction

"
" Unite
"
let bundle = neobundle#get('unite')
function! bundle.hooks.on_source(bundle)
	if executable('ack-grep')
		let g:unite_source_grep_command = 'ack-grep'
		let g:unite_source_grep_default_opts = '--noheading --nocolor -k -H'
		let g:unite_source_grep_recursive_opt = ''
	endif

	let g:unite_data_directory = util#path_join(g:vimfiles_path, 'cache')
	call util#mkdir_if_none(g:unite_data_directory)
	let g:unite_source_session_default_session_name = 'default'
	let g:unite_source_session_path = expand('~/.vim/sessions')
	let g:unite_force_overwrite_statusline = 0
	let g:unite_winheight = 20
	call unite#filters#matcher_default#use(['matcher_fuzzy'])
	call unite#filters#sorter_default#use(['sorter_rank'])
	if has('multi_byte')
		call unite#custom#profile('default', 'context', {
			\     'prompt': '» ',
			\     'silent': 1,
			\     'direction': 'botright',
			\     'prompt_direction': 'top'
			\ })
	else
		call unite#custom#profile('default', 'context', {
			\     'prompt': '>> ',
			\     'silent': 1,
			\     'direction': 'botright',
			\     'prompt_direction': 'top'
			\ })
	endif
	call unite#custom#profile('files', 'context', {'start_insert': 1})
	call unite#custom#profile('buffers', 'context', {'start_insert': 1})
	call unite#custom#profile('search', 'context', {'no_quit': 1})

	nnoremap <leader>f :Unite -buffer-name=files file_rec<cr>
	nnoremap <leader>b :Unite -profile-name=files -buffer-name=buffers buffer<cr>
	nnoremap <leader>/ :Unite -buffer-name=search grep<cr>

	if has('autocmd')
		augroup vimrc
			" apply unite buffer settings
			autocmd FileType unite call UniteBufferSettings()
		augroup END
	endif
endfunction

let bundle = neobundle#get('unite-outline')
function! bundle.hooks.on_source(bundle)
	call unite#custom#profile('outline', 'context', {'no_split': 1})
	nnoremap <leader>o :Unite -buffer-name=outline outline<cr>
endfunction

let bundle = neobundle#get('unite-session')
function! bundle.hooks.on_source(bundle)
	nnoremap <leader>s :Unite -buffer-name=sessions session<cr>
	command! -nargs=? LoadSession UniteSessionLoad <args>
	command! -nargs=? SaveSession UniteSessionSave <args>
endfunction!

function! UniteBufferSettings()
	imap <buffer> <tab>   <Plug>(unite_choose_action)
	nmap <buffer> <tab>   <Plug>(unite_choose_action)
	imap <buffer> <s-tab> <Plug>(unite_exit)
	nmap <buffer> <s-tab> <Plug>(unite_exit)
	imap <buffer> <c-n>   <Plug>(unite_select_next_line)
	nmap <buffer> <c-n>   <Plug>(unite_select_next_line)
	imap <buffer> <c-p>   <Plug>(unite_select_previous_line)
	nmap <buffer> <c-p>   <Plug>(unite_select_previous_line)
endfunction

"
" YouCompleteMe
"
let bundle = neobundle#get('YouCompleteMe')
function! bundle.hooks.on_source(bundle)
	let g:ycm_enable_diagnostic_signs = 0
	let g:ycm_enable_diagnostic_highlighting = 0
	let g:ycm_always_populate_location_list = 1
	let g:ycm_global_ycm_extra_conf = util#path_join(g:vimfiles_path, 'ycm/ycm_extra_conf.py')
	let g:ycm_confirm_extra_conf = 1
	let g:ycm_cache_omnifunc = 1
	let g:ycm_collect_identifiers_from_tags_files = 1
	let g:ycm_extra_conf_c_flags = '-xc -std=c11 -Wall -Wextra'
	let g:ycm_extra_conf_cpp_flags = '-xc++ -std=c++11 -Wall -Wextra'
	let g:ycm_extra_conf_vim_data = [
				\   '&filetype',
				\   'g:ycm_extra_conf_c_flags',
				\   'g:ycm_extra_conf_cpp_flags'
				\]

	if has('autocmd')
		augroup vimrc
			autocmd FileType c      nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
			autocmd FileType cpp    nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
			autocmd FileType objc   nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
			autocmd FileType objcpp nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
			autocmd FileType cs     nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
			autocmd FileType python nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
		augroup END
	endif
endfunction

" --------
" Mappings
" --------
noremap  <left>  <nop>
noremap  <right> <nop>
noremap  <up>    <nop>
noremap  <down>  <nop>
cnoremap <left>  <nop>
cnoremap <right> <nop>
cnoremap <up>    <nop>
cnoremap <down>  <nop>
inoremap <left>  <nop>
inoremap <right> <nop>
inoremap <up>    <nop>
inoremap <down>  <nop>

" yank to end of line
nnoremap Y y$

" treat line wraps as real lines
nnoremap j gj
nnoremap k gk

" indent and un-indent
vnoremap > >gv
vnoremap < <gv

" visually select last edited/pasted text
nnoremap gV `[v`]

" sudo write file
cmap w!! w !sudo tee > /dev/null %

" Set tab width using a nice prompt
function! SetTab()
	let l:tabstop = 1 * input('setlocal tabstop = softtabstop = shiftwidth = ')
	if l:tabstop > 0
		let &l:tw = l:tabstop
		let &l:sts = l:tabstop
		let &l:sw = l:tabstop
	endif
	let l:et = input('setlocal expandtab = ')
	if l:et == 0
		setlocal noexpandtab
	else
		setlocal expandtab
	end
	echo
	echo "\r"
	call SummarizeTabs()
endfunction

" Summarize current tab info
function! SummarizeTabs()
	try
		echom 'tabstop=' . &l:ts . ' softtabstop=' . &l:sts . ' shiftwidth=' . &l:sw .
					\' ' . ((&l:et) ? 'expandtab' : 'noexpandtab')
	endtry
endfunction

command! -nargs=0 SetTab call SetTab()
command! -nargs=0 SummarizeTabs call SummarizeTabs()

" Remove trailing whitespace
function! RemoveTrailingWhitespace()
	if exists('b:no_strip_whitespace') && b:no_strip_whitespace == 1
		return
	endif

	exe 'normal mz'
	%s/\s\+$//ge
	exe 'normal `z'
endfunction

if has('autocmd')
	augroup vimrc
		autocmd BufWritePre * :call RemoveTrailingWhitespace()
	augroup END
endif
