" -----
" Setup
" -----
scriptencoding utf-8

if has('win32')
	let g:vimfiles_path = '~/vimfiles'
else
	let g:vimfiles_path = '~/.vim'
endif

let g:bundle_path = util#path_join(g:vimfiles_path, 'bundle')

let g:plug_window=''

call plug#begin(g:bundle_path)

" appearance
Plug 'chriskempson/base16-vim'
Plug 'kernan/vim-modestatus'

" vcs integration
Plug 'mhinz/vim-signify'

" languages
Plug 'derekwyatt/vim-scala'
Plug 'elzr/vim-json'
Plug 'fatih/vim-go'
Plug 'groenewege/vim-less'
Plug 'oranget/vim-csharp'
Plug 'octol/vim-cpp-enhanced-highlight'
Plug 'tikhomirov/vim-glsl'
Plug 'tpope/vim-git'
Plug 'tpope/vim-markdown'

" unite
Plug 'shougo/vimproc.vim', {'do': 'make'}
Plug 'shougo/unite.vim'
Plug 'shougo/unite-outline'
Plug 'shougo/unite-session'

" snippets
Plug 'sirver/ultisnips'
Plug 'kernan/vim-snippets'

" other
Plug 'derekwyatt/vim-fswitch', {'for': ['c', 'cpp']}
Plug 'junegunn/vim-easy-align', {'on': ['<Plug>EasyAlign', 'EasyAlign']}
Plug 'junegunn/vader.vim', {'on': 'Vader', 'for': 'vader'}
Plug 'kana/vim-textobj-entire'
Plug 'kana/vim-textobj-user'
Plug 'lokaltog/vim-easymotion'
Plug 'mbbill/undotree', {'on': ['UndotreeShow', 'UndotreeHide', 'UndotreeToggle']}
Plug 'raimondi/delimitmate'
Plug 'scrooloose/syntastic'
Plug 'tommcdo/vim-exchange'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-endwise'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'valloric/listtoggle'
Plug 'xolox/vim-easytags'
Plug 'xolox/vim-misc'

if has('unix')
	Plug 'valloric/youcompleteme', {'do': './install.sh --clang-completer --system-libclang'}
endif

if has('win32')
	Plug 'xolox/vim-shell'
endif

call plug#end()

if has('autocmd')
	augroup vimrc
		autocmd!
	augroup END
endif

" --------
" Settings
" --------
call util#mkdir_if_none(util#path_join(g:vimfiles_path, 'undo'))

filetype plugin indent on

set omnifunc=syntaxcomplete#Complete
set completeopt=menu,menuone,longest

let mapleader = "\\"
let maplocalleader = "\\"
map <space> <leader>

set history=1000
set undoreload=1000
set undodir=$HOME/.vim/undo
set undofile
set nobackup
set noswapfile

set pastetoggle=<F2>

if has('mouse')
	set mouse=a
endif

if has('unnamedplus')
	set clipboard=unnamedplus,unnamed
else
	set clipboard+=unnamed
endif

set backspace=indent,eol,start

set autoread
set hidden

set noerrorbells novisualbell t_vb=
set shortmess=atsoOI
set showcmd
set scrolloff=3
set ttyfast
set lazyredraw
set t_ut=
set noshowmode
set laststatus=2

if has('multi_byte') && !has('win32')
	set listchars=tab:▸\ ,eol:¬,extends:»,precedes:«
	set showbreak=…
else
	set listchars=tab:>\ ,eol:$,extends:>,precedes:<
	set showbreak=~
endif

set list

set wildmenu
set wildmode=longest:full,full
set wildignore+=.hg,.git,.svn                    " version control files
set wildignore+=*.aux,*.out,*.toc                " LaTeX build files
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.class                          " java compiled objects
set wildignore+=*.luac                           " lua byte code
set wildignore+=*.pyc                            " python byte code
set wildignore+=*.sw                             " vim swap files
set wildignore+=*.DS_Store                       " OSX something

set tabstop=4
set shiftwidth=4
set softtabstop=4
set noexpandtab
set shiftround

set wrap
set textwidth=80
set formatoptions=cqrn1j
set smartindent

set magic
set ignorecase
set smartcase
set incsearch
set hlsearch
set gdefault

set concealcursor=c
set conceallevel=2

set number
set relativenumber
set cursorline

if has('autocmd')
	augroup vimrc
		" automatically resize splits on window resize
		autocmd VimResized * :wincmd =
		" restore line position
		autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
		" switch to/from relative line numbers
		autocmd BufEnter,FocusGained * setlocal number relativenumber
		autocmd BufLeave,FocusLost   * setlocal number norelativenumber
		autocmd InsertEnter * setlocal number norelativenumber
		autocmd InsertLeave * setlocal number relativenumber
		" enable/disable cursor line depending on window focus
		autocmd BufEnter,FocusGained * setlocal number cursorline
		autocmd BufLeave,FocusLost   * setlocal number nocursorline
	augroup END
endif

" -----
" Theme
" -----
syntax on

let g:base16colorspace = 256
set background=dark
colorscheme base16-monokai

"
" Modestatus
"
" TODO(2014-12-09) Apply colors on a per-colorscheme basis.
hi StatusLine         guifg=#a59f85 guibg=#49483e gui=none ctermfg=20     ctermbg=19  cterm=none
hi StatusLineNC       guifg=#75715e guibg=#383830 gui=none ctermfg=08     ctermbg=18  cterm=none
hi ModestatusMode     guifg=Yellow  guibg=#49483e gui=bold ctermfg=Yellow ctermbg=19  cterm=bold
hi ModestatusFilename guifg=#a59f85 guibg=#49483e gui=bold ctermfg=20     ctermbg=19  cterm=bold
hi ModestatusModified guifg=Red     guibg=#49483e gui=bold ctermfg=Red    ctermbg=19  cterm=bold
hi ModestatusError    guifg=White   guibg=#af0000 gui=none ctermfg=White  ctermbg=124 cterm=none
hi ModestatusWarning  guifg=Black   guibg=#dfaf00 gui=none ctermfg=Black  ctermbg=178 cterm=none

call modestatus#extensions#enable('core')
call modestatus#extensions#enable('loclist')

let g:modestatus#statusline = {
	\ 'active': {
	\     'left': [
	\         'line_percent',
	\         'position',
	\         'mode',
	\         'filename',
	\         'modified',
	\         'readonly',
	\         'paste',
	\         'filetype',
	\         'encoding',
	\         'fileformat',
	\         'loclist_errors',
	\         'loclist_warnings'
	\     ],
	\     'right': [
	\     ]
	\ },
	\ 'inactive': {
	\     'left': [
	\         'filename',
	\         'modified',
	\         'readonly',
	\         'filetype',
	\         'encoding',
	\         'fileformat',
	\         'loclist_errors',
	\         'loclist_warnings'
	\     ],
	\     'right': [
	\     ]
	\ }}

let g:modestatus#extensions#core#filename_override = {
	\     '[No Name]': ''
	\ }

let g:modestatus#extensions#core#filetype_override = {
	\     'qf': '',
	\     'diff': '',
	\     'undotree': 'Undo Tree'
	\ }

call modestatus#options#add('filename', {
	\ 'active': {
	\     'color': 'ModestatusFilename'
	\ }})
call modestatus#options#add('mode', {
	\ 'active': {
	\     'color': 'ModestatusMode',
	\     'format': '‹%s›'
	\ }})
call modestatus#options#add('modified', {
	\ 'active': {
	\     'color': 'ModestatusModified'
	\ }})
call modestatus#options#add('readonly', {
	\ 'active': {
	\     'color': 'ModestatusModified'
	\ }})
call modestatus#options#add('paste', {
	\ 'active': {
	\     'color': 'ModestatusModified'
	\ }})
call modestatus#options#add('filetype', {
	\ 'active': {
	\     'format': '[%s]'
	\ },
	\ 'inactive': {
	\     'format': '[%s]'
	\ }})
call modestatus#options#add('encoding', {
	\ 'active': {
	\     'format': '[%s:',
	\     'separator': ''
	\ },
	\ 'inactive': {
	\     'format': '[%s:',
	\     'separator': ''
	\ }})
call modestatus#options#add('fileformat', {
	\ 'active': {
	\     'format': '%s]'
	\ },
	\ 'inactive': {
	\     'format': '%s]'
	\ }})
call modestatus#options#add('loclist_errors', {
	\ 'active': {
	\     'color': 'ModestatusError',
	\     'format': ' %s ',
	\     'separator': ''
	\ },
	\ 'inactive': {
	\     'separator': ''
	\ }})
call modestatus#options#add('loclist_warnings', {
	\ 'active': {
	\     'color': 'ModestatusWarning',
	\     'format': ' %s ',
	\     'separator': ''
	\ },
	\ 'inactive': {
	\     'separator': ''
	\ }})

" ---------
" Languages
" ---------

"
" C++
"
let g:cpp_class_scope_highlight = 1
let g:cpp_experimental_template_highlight = 0

"
" Go
"
let g:go_fmt_command = 'goimports'

" -------
" Plugins
" -------

"
" DelimitMate
"
let delimitMate_matchpairs = "(:),[:],{:}"
let delimitMate_quotes = "\" ' `"
let delimitMate_expand_cr = 1
let delimitMate_jump_expansion = 1

if has('autocmd')
	augroup vimrc
		" filetype specific pairs
		" filetype specific quotes
		autocmd FileType vim let b:delimitMate_quotes = "'"
		" filetype specific nesting
		autocmd FileType python let b:delimitMate_nesting_quotes = ['"']
	augroup END
endif

"
" EasyMotion
"
let g:EasyMotion_enter_jump_first = 1
let g:EasyMotion_smartcase = 1
let g:EasyMotion_use_smartsign_us = 1
let g:EasyMotion_startofline = 0
let g:EasyMotion_move_highlight = 0
map m  <Plug>(easymotion-prefix)
map /  <Plug>(easymotion-sn)
omap / <Plug>(easymotion-tn)
map n  <Plug>(easymotion-next)
map N  <Plug>(easymotion-prev)

"
" EasyTags
"
set tags=./tags;$HOME
let g:easytags_by_filetype = util#path_join(g:vimfiles_path, 'tags')
call util#mkdir_if_none(g:easytags_by_filetype)
let g:easytags_dynamic_files = 1
let g:easytags_include_members = 1
let g:easytags_updatetime_warn = 0
let g:easytags_always_enabled = 1
let g:easytags_auto_highlight = 0
let g:easytags_async = 1

"
" FSwitch
"
if has('autocmd')
	augroup vimrc
		autocmd FileType c,cpp nmap <buffer> <leader>af :FSHere<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>al :FSRight<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aL :FSSplitRight<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>ah :FSLeft<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aH :FSSplitLeft<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>ak :FSAbove<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aK :FSSplitAbove<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aj :FSBelow<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aJ :FSSplitBelow<cr>
	augroup END
endif

"
" ListToggle
"
let g:lt_location_list_toggle_map = '<leader>l'
let g:lt_quickfix_list_toggle_map = '<leader>q'
let g:lt_height = 10

"
" Signify
"
let g:signify_disable_by_default = 0
let g:signify_sign_overwrite = 0
let g:signify_sign_add = '+'
let g:signify_sign_change = '~'
let g:signify_sign_delete = '-'
if has('multi_byte') && !has('win32')
	let g:signify_sign_delete_first_line = '‾'
else
	let g:signify_sign_delete_first_line = '^'
endif

"
" Syntastic
"
let g:syntastic_check_on_wq = 0
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 1
let g:syntastic_echo_current_error = 1
let g:syntastic_enable_signs = 0
let g:syntastic_enable_highlighting = 0
let g:syntastic_enable_balloons = 0
let g:syntastic_aggregate_errors = 1
let g:syntastic_python_checkers = ['pylint', 'flake8']
let g:syntastic_tex_checkers = ['chktex']

"
" UndoTree
"
let g:undotree_WindowLayout = 2
let g:undotree_SplitWidth = 40
let g:undotree_DiffpanelHeight = 15
let g:undotree_DiffAutoOpen = 0
command! -nargs=0 UndoTree silent UndotreeToggle

"
" UltiSnips
"
let g:UltiSnipsEditSplit = 'vertical'
let g:UltiSnipsExpandTrigger = '<c-j>'
let g:UltiSnipsJumpForwardTrigger = '<c-j>'
let g:UltiSnipsJumpBackwardTrigger = '<c-k>'

"
" Unite
"
if executable('ack-grep')
	let g:unite_source_grep_command = 'ack-grep'
	let g:unite_source_grep_default_opts = '--noheading --nocolor -k -H'
	let g:unite_source_grep_recursive_opt = ''
endif

let g:unite_data_directory = util#path_join(g:vimfiles_path, 'cache')
call util#mkdir_if_none(g:unite_data_directory)
let g:unite_source_session_default_session_name = 'default'
let g:unite_source_session_path = expand('~/.vim/sessions')
let g:unite_force_overwrite_statusline = 0
let g:unite_winheight = 20
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])
if has('multi_byte') && !has('win32')
	call unite#custom#profile('default', 'context', {
		\     'prompt': '» ',
		\     'silent': 1,
		\     'direction': 'botright',
		\     'prompt_direction': 'top'
		\ })
else
	call unite#custom#profile('default', 'context', {
		\     'prompt': '>> ',
		\     'silent': 1,
		\     'direction': 'botright',
		\     'prompt_direction': 'top'
		\ })
endif
call unite#custom#profile('files', 'context', {'start_insert': 1})
call unite#custom#profile('buffers', 'context', {'start_insert': 1})
call unite#custom#profile('search', 'context', {'no_quit': 1})

nnoremap <leader>f :Unite -buffer-name=files file_rec<cr>
nnoremap <leader>b :Unite -profile-name=files -buffer-name=buffers buffer<cr>
nnoremap <leader>/ :Unite -buffer-name=search grep<cr>

if has('autocmd')
	augroup vimrc
		" apply unite buffer settings
		autocmd FileType unite call s:unite_settings()
	augroup END
endif

"
" Unite Outline
"
call unite#custom#profile('outline', 'context', {'no_split': 1})
nnoremap <leader>o :Unite -buffer-name=outline outline<cr>

"
" Unite Session
"
nnoremap <leader>s :Unite -buffer-name=sessions session<cr>
command! -nargs=? LoadSession UniteSessionLoad <args>
command! -nargs=? SaveSession UniteSessionSave <args>

function! s:unite_settings()
	imap <buffer> <tab>   <Plug>(unite_choose_action)
	nmap <buffer> <tab>   <Plug>(unite_choose_action)
	imap <buffer> <s-tab> <Plug>(unite_exit)
	nmap <buffer> <s-tab> <Plug>(unite_exit)
	imap <buffer> <c-n>   <Plug>(unite_select_next_line)
	nmap <buffer> <c-n>   <Plug>(unite_select_next_line)
	imap <buffer> <c-p>   <Plug>(unite_select_previous_line)
	nmap <buffer> <c-p>   <Plug>(unite_select_previous_line)
endfunction

"
" YouCompleteMe
"
let g:ycm_global_ycm_extra_conf = util#path_join(g:vimfiles_path, 'ycm/ycm_extra_conf.py')
let g:ycm_confirm_extra_conf = 1
let g:ycm_cache_omnifunc = 1
let g:ycm_collect_identifiers_from_tags_files = 1
let g:ycm_extra_conf_c_flags    = '-std=c11 -Wall -Wextra -pedantic'
let g:ycm_extra_conf_cpp_flags  = '-std=c++11 -Wall -Wextra -pedantic'
let g:ycm_extra_conf_objc_flags = '-Wall -Wextra -pedantic'
let g:ycm_extra_conf_vim_data = [
	\   '&filetype',
	\   'g:ycm_extra_conf_c_flags',
	\   'g:ycm_extra_conf_cpp_flags'
	\]

if has('autocmd')
	augroup vimrc
		autocmd FileType c      nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType cpp    nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType objc   nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType objcpp nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType cs     nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType python nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
	augroup END
endif

" --------
" Mappings
" --------
noremap  <left>  <nop>
noremap  <right> <nop>
noremap  <up>    <nop>
noremap  <down>  <nop>
cnoremap <left>  <nop>
cnoremap <right> <nop>
cnoremap <up>    <nop>
cnoremap <down>  <nop>
inoremap <left>  <nop>
inoremap <right> <nop>
inoremap <up>    <nop>
inoremap <down>  <nop>

" yank to end of line
nnoremap Y y$

" treat line wraps as real lines
nnoremap j gj
nnoremap k gk

" indent and un-indent
vnoremap > >gv
vnoremap < <gv

" visually select last edited/pasted text
nnoremap gV `[v`]

" sudo write file
cmap w!! w !sudo tee > /dev/null %

" Set tab width using a nice prompt
function! s:set_tabs()
	echohl Question
	let l:tabstop = 1 * input('setlocal tabstop = softtabstop = shiftwidth = ')
	echohl None
	if l:tabstop > 0
		let &l:ts = l:tabstop
		let &l:sts = l:tabstop
		let &l:sw = l:tabstop
	endif
	let l:et = input('setlocal expandtab = ')
	if l:et == 0
		setlocal noexpandtab
	else
		setlocal expandtab
	end
	echo
	echo "\r"
	call s:summarize_tabs()
endfunction

" Summarize current tab info
function! s:summarize_tabs()
	try
		echom 'tabstop=' . &l:ts . ' softtabstop=' . &l:sts . ' shiftwidth=' . &l:sw .
					\' ' . ((&l:et) ? 'expandtab' : 'noexpandtab')
	endtry
endfunction

command! -nargs=0 SetTabs call s:set_tabs()
command! -nargs=0 SummarizeTabs call s:summarize_tabs()

" Remove trailing whitespace
function! s:strip_trailing_whitespace()
	if exists('b:no_strip_whitespace') && b:no_strip_whitespace == 1
		return
	endif

	exe 'normal mz'
	%s/\s\+$//ge
	exe 'normal `z'
endfunction

command! -nargs=0 StripTrailingWhitespace call s:strip_trailing_whitespace()
