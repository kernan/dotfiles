call plug#begin()

" appearance
Plug 'chriskempson/base16-vim'
Plug 'kernan/vim-modestatus'
" languages
Plug 'sheerun/vim-polyglot'
" syntax checking
Plug 'w0rp/ale'
" code completion
Plug 'shougo/neocomplete.vim'
Plug 'davidhalter/jedi-vim', {'for': 'python'}
Plug 'ternjs/tern_for_vim', {'do': 'npm install', 'for': 'javascript'}
" vcs integration
Plug 'mhinz/vim-signify'
" testing
Plug 'junegunn/vader.vim', {'on': 'Vader', 'for': 'vader'}
" searching
Plug 'easymotion/vim-easymotion'
Plug 'haya14busa/incsearch.vim'
Plug 'haya14busa/incsearch-easymotion.vim'
Plug 'haya14busa/incsearch-fuzzy.vim'
Plug 'haya14busa/vim-asterisk'
" other
Plug 'jiangmiao/auto-pairs'
Plug 'kana/vim-textobj-entire'
Plug 'kana/vim-textobj-user'
Plug 'shougo/denite.nvim'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-endwise'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'

call plug#end()

" clear autocmd
augroup vimrc
	autocmd!
augroup END

let mapleader = "\<space>"

filetype plugin indent on
syntax enable

set ttimeout
set ttimeoutlen=100

set backspace=indent,eol,start

set autoindent
set smarttab

set ignorecase
set smartcase
set incsearch

if has('multi_byte')
	set encoding=utf-8
endif

if has('multi_byte')
	set listchars=eol:Â¬,tab:Â»\ ,trail:Â·
else
	set listchars=eol:$,tab:>\ ,trail:-
endif

if has('unnamedplus')
	set clipboard=unnamedplus,unnamed
else
	set clipboard+=unnamed
endif

if has('persistent_undo')
	set undofile
	if has('win32')
		set undodir=~/vimfiles/.undo//
	else
		set undodir=~/.vim/.undo//
	endif
endif

if has('win32')
	set backupdir=~/vimfiles/.backup//
	set directory=~/vimfiles/.swap//
else
	set backupdir=~/.vim/.backup//
	set directory=~/.vim/.swap//
endif

set completeopt=menu,menuone,noselect

set wildmenu
set wildmode=longest:full,full
set wildignore+=.hg,.git,.svn                    " version control files
set wildignore+=*.aux,*.out,*.toc                " LaTeX build files
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.class                          " java compiled objects
set wildignore+=*.luac                           " lua byte code
set wildignore+=*.pyc                            " python byte code
set wildignore+=*.sw                             " vim swap files
set wildignore+=*.DS_Store                       " OSX something

set nrformats-=octal
set formatoptions+=j
set fileformats=unix,dos,mac

set number
set relativenumber

set scrolloff=1
set sidescrolloff=5

if has('mouse')
	set mouse=a
endif

set display+=lastline
set laststatus=2
set noshowmode

set autoread
set hidden
set cursorline
set shortmess=atI
set lazyredraw
set splitbelow
set splitright
set belloff=all

set omnifunc=syntaxcomplete#Complete

augroup vimrc
	" automatically resize splits on window resize
	autocmd VimResized * :wincmd =
	" redraw immediately when entering vim
	autocmd VimEnter * redraw!
	" restore line position
	autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
	" switch to/from relative line numbers
	autocmd BufEnter,FocusGained * setlocal number relativenumber
	autocmd BufLeave,FocusLost   * setlocal number norelativenumber
	autocmd InsertEnter * setlocal number norelativenumber
	autocmd InsertLeave * setlocal number relativenumber
	" enable/disable cursor line depending on window focus
	autocmd BufEnter,FocusGained * setlocal number cursorline
	autocmd BufLeave,FocusLost   * setlocal number nocursorline
	" always show the sign column
	autocmd BufEnter * sign define dummy
	autocmd BufEnter * execute 'sign place 9999 line=1 name=dummy buffer=' . bufnr('')
augroup END

let g:base16colorspace = 256
set background=dark
colorscheme base16-monokai

" Statusline (via Modestatus)
function! s:setup_statusline_colorscheme()
	hi StatusLine guifg=#a59f85 guibg=#49483e gui=none ctermfg=20 ctermbg=19 cterm=none
	hi StatusLineNC guifg=#75715e guibg=#49483e gui=none ctermfg=08 ctermbg=19 cterm=none
	hi ModestatusMode guifg=Yellow guibg=#49483e gui=none ctermfg=Yellow ctermbg=19 cterm=none
	hi ModestatusRed guifg=Red guibg=#49483e gui=none ctermfg=Red ctermbg=19 cterm=none
	hi ModestatusHunksAdded guifg=#a6e22e guibg=#49483e gui=none ctermfg=2 ctermbg=19 cterm=none
	hi ModestatusHunksModified guifg=#66d9ef guibg=#49483e gui=none ctermfg=4 ctermbg=19 cterm=none
	hi ModestatusHunksRemoved guifg=#f92672 guibg=#49483e gui=none ctermfg=1 ctermbg=19 cterm=none
	hi ModestatusLoclistWarnings guifg=Yellow guibg=#49483e gui=none ctermfg=Yellow ctermbg=19 cterm=none
	hi ModestatusLoclistErrors guifg=Red guibg=#49483e gui=none ctermfg=Red ctermbg=19 cterm=none
endfunction

call s:setup_statusline_colorscheme()

let g:modestatus#statusline = ['line_percent', 'line', 'column', 'mode', 'filename', 'modified', 'readonly', 'hunks_added', 'hunks_modified', 'hunks_removed', 'filetype', 'encoding', 'bomb', 'fileformat', 'loclist_errors', 'loclist_warnings']
let g:modestatus#statusline_override_denite = ['denite_line_percent', 'denite_line', 'denite_line_max', 'denite_mode', 'denite_sources', 'denite_path', 'filetype']
let g:modestatus#statusline_override_qf = ['line_percent_always', 'line_always', 'line_max_always', 'filetype']

let g:modestatus#parts#core#readonly_symbol = has('multi_byte') ? 'ðŸ”’' : 'RO'

call modestatus#options#add('bomb', 'format', '-%s')
call modestatus#options#add('bomb', 'separator', '')
call modestatus#options#add('denite_line', 'separator', '/')
call modestatus#options#add('denite_mode', 'color', 'ModestatusMode')
call modestatus#options#add('denite_mode', 'format', has('multi_byte') ? 'â€¹%sâ€º' : '<%s>')
call modestatus#options#add('encoding', 'format', '[%s')
call modestatus#options#add('encoding', 'separator', '')
call modestatus#options#add('fileformat', 'format', ':%s]')
call modestatus#options#add('hunks_added', 'color', 'ModestatusHunksAdded')
call modestatus#options#add('hunks_modified', 'color', 'ModestatusHunksModified')
call modestatus#options#add('hunks_removed', 'color', 'ModestatusHunksRemoved')
call modestatus#options#add('line', 'separator', ',')
call modestatus#options#add('line_always', 'separator', '/')
call modestatus#options#add('loclist_errors', 'color', 'ModestatusLoclistErrors')
call modestatus#options#add('loclist_errors', 'format', 'â€¢%s')
call modestatus#options#add('loclist_warnings', 'color', 'ModestatusLoclistWarnings')
call modestatus#options#add('loclist_warnings', 'format', 'â€¢%s')
call modestatus#options#add('mode', 'format', has('multi_byte') ? 'â€¹%sâ€º' : '<%s>')
call modestatus#options#add('mode', 'color', 'ModestatusMode')
call modestatus#options#add('modified', 'color', 'ModestatusRed')
call modestatus#options#add('readonly', 'color', 'ModestatusRed')

augroup vimrc
	autocmd ColorScheme * call s:setup_statusline_colorscheme()
	" overrides
	autocmd FileType denite setlocal statusline=%!modestatus#statusline(winnr(),'denite')
	autocmd FileType qf setlocal statusline=%!modestatus#statusline(winnr(),'qf')
augroup END

" yank to end of line
nnoremap Y y$

" treat line wraps as real lines
nnoremap j gj
nnoremap k gk
nnoremap gj j
nnoremap gk k

" indent and un-indent
vnoremap > >gv
vnoremap < <gv

" visually select last edited/pasted text
nnoremap gV `[v`]

" automatically jump to the end of the last paste
vnoremap <silent> y y`]
vnoremap <silent> p p`]
nnoremap <silent> p p`]

" sudo write file
cmap w!! w !sudo tee > /dev/null %

" Macro over visual range
function! s:execute_macro_over_visual_range()
	echo "@".getcmdline()
	execute ":'<,'> normal @".nr2char(getchar())
endfunction

xnoremap @ :<C-u>call <SID>execute_macro_over_visual_range()<CR>

" ALE settings
let g:ale_sign_error = 'E '
let g:ale_sign_warning = 'W '

" Denite settings
call denite#custom#option('default', 'auto_resize', 1)
call denite#custom#option('default', 'statusline', 0)
call denite#custom#option('default', 'highlight_mode_normal', 'CursorLine')
call denite#custom#option('default', 'highlight_mode_insert', 'CursorLine')
call denite#custom#option('grep', 'mode', 'normal')
call denite#custom#option('grep', 'auto_resize', 1)
call denite#custom#option('grep', 'statusline', 0)
call denite#custom#option('grep', 'highlight_mode_normal', 'CursorLine')
call denite#custom#option('grep', 'highlight_mode_insert', 'CursorLine')

" file_rec command
if executable('ag')
	call denite#custom#var('file_rec', 'command', ['ag', '--follow', '--nocolor', '--nogroup', '-g', ''])
endif

" grep command
if executable('ag')
	call denite#custom#var('grep', 'command', ['ag'])
	call denite#custom#var('grep', 'default_opts', ['-i', '--vimgrep'])
	call denite#custom#var('grep', 'recursive_opts', [])
	call denite#custom#var('grep', 'pattern_opt', [])
	call denite#custom#var('grep', 'separator', ['--'])
	call denite#custom#var('grep', 'final_opts', [])
endif

" mappings
call denite#custom#map('insert', '<Esc>', '<denite:enter_mode:normal>')
call denite#custom#map('normal', '<Esc>', '<denite:quit>')
call denite#custom#map('insert', '<C-n>', '<denite:move_to_next_line>', 'noremap')
call denite#custom#map('insert', '<C-p>', '<denite:move_to_previous_line>', 'noremap')
nnoremap <leader>f :Denite file_rec<cr>
nnoremap <leader>b :Denite buffer<cr>
nnoremap <leader>/ :Denite -buffer-name=grep grep<cr>

" EasyMotion, Incsearch, Asterisk
map / <Plug>(incsearch-forward)
map ? <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)
" auto nohlsearch
set hlsearch
let g:incsearch#auto_nohlsearch = 1
map n <Plug>(incsearch-nohl-n)
map N <Plug>(incsearch-nohl-N)
map * <Plug>(incsearch-nohl)<Plug>(asterisk-*)
map g* <Plug>(incsearch-nohl)<Plug>(asterisk-g*)
map # <Plug>(incsearch-nohl)<Plug>(asterisk-#)
map g# <Plug>(incsearch-nohl)<Plug>(asterisk-g#)
map z* <Plug>(incsearch-nohl0)<Plug>(asterisk-z*)
map gz* <Plug>(incsearch-nohl0)<Plug>(asterisk-gz*)
map z# <Plug>(incsearch-nohl0)<Plug>(asterisk-z#)
map gz# <Plug>(incsearch-nohl0)<Plug>(asterisk-gz#)
" fuzzy search
map z/ <Plug>(incsearch-fuzzy-/)
map z? <Plug>(incsearch-fuzzy-?)
map zg/ <Plug>(incsearch-fuzzy-stay)
" search motion (via easymotion)
function! s:config_easymotion(...)
	return extend(copy({
		\   'modules': [incsearch#config#easymotion#module()],
		\   'keymap': {"\<CR>": '<Over>(easymotion)'},
		\   'is_expr': 0,
		\   'is_stay': 1
		\ }), get(a:, 1, {}))
endfunction
noremap <expr> <leader><leader>/ incsearch#go(<SID>config_easymotion())
" fuzzy motion (via easymotion)
function! s:config_easyfuzzymotion(...)
	return extend(copy({
		\   'converters': [incsearch#config#fuzzy#converter()],
		\   'modules': [incsearch#config#easymotion#module()],
		\   'keymap': {"\<CR>": '<Over>(easymotion)'},
		\   'is_expr': 0,
		\   'is_stay': 1
		\ }), get(a:, 1, {}))
endfunction
noremap <expr> <leader><leader>z/ incsearch#go(<SID>config_easyfuzzymotion())

" Neocomplete
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_smart_case = 1
if !exists('g:neocomplete#force_omni_input_patterns')
	let g:neocomplete#force_omni_input_patterns = {}
endif
" tab completion
inoremap <expr><tab> pumvisible() ? "\<C-n>" : "\<tab>"
inoremap <expr><s-tab> pumvisible() ? "\<C-p>" : "\<s-tab>"
inoremap <expr><esc> pumvisible() ? "\<C-y>\<esc>" : "\<esc>"

" Signify
let g:signify_sign_change = '~'
let g:signify_sign_delete = '-'
