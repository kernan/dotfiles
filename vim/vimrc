" -----
" Setup
" -----
scriptencoding utf-8

if has('win32')
	let g:vimfiles_path = '~/vimfiles'
else
	let g:vimfiles_path = '~/.vim'
endif

let g:bundle_path = util#path_join(g:vimfiles_path, 'bundle')

if has('vim_starting')
	set nocompatible
	filetype off
	exec 'set runtimepath+=' . expand(util#path_join(g:bundle_path, 'neobundle'))
endif

let g:neobundle#enable_name_conversion = 1
call neobundle#begin(g:bundle_path)

NeoBundleFetch 'Shougo/neobundle.vim'

NeoBundle 'Shougo/vimproc.vim', {
	\   'build': {
	\     'windows': 'tools\\update-dll-mingw',
	\     'cygwin': 'make -f make_cygwin.mak',
	\     'mac': 'make -f make_mac.mak',
	\     'unix': 'make -f make_unix.mak'
	\   }
	\ }

" appearance
NeoBundle 'chriskempson/base16-vim'
NeoBundle 'kernan/vim-modestatus'

" vcs integration
NeoBundle 'mhinz/vim-signify'

" languages
NeoBundle 'derekwyatt/vim-scala'
NeoBundle 'elzr/vim-json'
NeoBundle 'groenewege/vim-less'
NeoBundle 'oranget/vim-csharp'
NeoBundle 'octol/vim-cpp-enhanced-highlight'
NeoBundle 'tikhomirov/vim-glsl'
NeoBundle 'tpope/vim-git'
NeoBundle 'tpope/vim-markdown'

" unite
NeoBundle 'shougo/unite.vim', {'depends': 'shougo/vimproc.vim'}
NeoBundle 'shougo/unite-outline', {'depends': 'shougo/unite.vim'}
NeoBundle 'shougo/unite-session', {'depends': 'shougo/unite.vim'}

" snippets
NeoBundle 'sirver/ultisnips'
NeoBundle 'kernan/vim-snippets'

" other
NeoBundle 'matchit.zip'
NeoBundle 'derekwyatt/vim-fswitch'
NeoBundle 'kana/vim-textobj-entire', {'depends': 'kana/vim-textobj-user'}
NeoBundle 'lokaltog/vim-easymotion', {'depends': 'tpope/vim-repeat'}
NeoBundle 'nelstrom/vim-visual-star-search'
NeoBundle 'raimondi/delimitmate'
NeoBundle 'scrooloose/syntastic'
NeoBundle 'sjl/gundo.vim'
NeoBundle 'tommcdo/vim-exchange'
NeoBundle 'tpope/vim-abolish', {'depends': 'tpope/vim-repeat'}
NeoBundle 'tpope/vim-commentary', {'depends': 'tpope/vim-repeat'}
NeoBundle 'tpope/vim-endwise'
NeoBundle 'tpope/vim-surround', {'depends': 'tpope/vim-repeat'}
NeoBundle 'tpope/vim-unimpaired', {'depends': 'tpope/vim-repeat'}
NeoBundle 'valloric/listtoggle'
NeoBundle 'xolox/vim-easytags', {'depends': 'xolox/vim-misc', 'external_commands': 'ctags'}

if has('unix')
	NeoBundle 'valloric/youcompleteme'
endif

if has('win32')
	NeoBundle 'xolox/vim-shell'
endif

call neobundle#end()

if has('autocmd')
	augroup vimrc
		autocmd!
	augroup END
endif

" --------
" Settings
" --------
call util#mkdir_if_none(util#path_join(g:vimfiles_path, 'undo'))

filetype plugin indent on

set omnifunc=syntaxcomplete#Complete
set completeopt=menu,menuone,longest

let mapleader = "\\"
let maplocalleader = "\\"
map <space> <leader>

set history=1000
set undoreload=1000
set undodir=$HOME/.vim/undo
set undofile
set nobackup
set noswapfile

set pastetoggle=<F2>

if has('mouse')
	set mouse=a
endif

if has('unnamedplus')
	set clipboard=unnamedplus,unnamed
else
	set clipboard+=unnamed
endif

set backspace=indent,eol,start

set autoread
set hidden

set noerrorbells novisualbell t_vb=
set shortmess=atsoOI
set showcmd
set scrolloff=3
set ttyfast
set lazyredraw
set t_ut=
set noshowmode
set laststatus=2

if has('multi_byte') && !has('win32')
	set listchars=tab:▸\ ,eol:¬,extends:»,precedes:«
	set showbreak=…
else
	set listchars=tab:>\ ,eol:$,extends:>,precedes:<
	set showbreak=~
endif

set list

set wildmenu
set wildmode=longest:full,full
set wildignore+=.hg,.git,.svn                    " version control files
set wildignore+=*.aux,*.out,*.toc                " LaTeX build files
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.class                          " java compiled objects
set wildignore+=*.luac                           " lua byte code
set wildignore+=*.pyc                            " python byte code
set wildignore+=*.sw                             " vim swap files
set wildignore+=*.DS_Store                       " OSX something

set tabstop=4
set shiftwidth=4
set softtabstop=4
set noexpandtab
set shiftround

set wrap
set textwidth=79
set formatoptions=cqrn1j
set smartindent

set magic
set ignorecase
set smartcase
set incsearch
set hlsearch
set gdefault

set concealcursor=nc
set conceallevel=2

set number
set relativenumber

if has('autocmd')
	augroup vimrc
		" automatically resize splits on window resize
		autocmd VimResized * :wincmd =
		" restore line position
		autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
		" switch to/from relative line numbers
		autocmd BufEnter,FocusGained * setlocal number relativenumber
		autocmd BufLeave,FocusLost   * setlocal number norelativenumber
		autocmd InsertEnter * setlocal number norelativenumber
		autocmd InsertLeave * setlocal number relativenumber
	augroup END
endif

" -----
" Theme
" -----
syntax on

set cursorline
let g:base16colorspace = 256
set background=dark
colorscheme base16-monokai

" -------
" Plugins
" -------

"
" DelimitMate
"
let delimitMate_matchpairs = "(:),[:],{:}"
let delimitMate_quotes = "\" ' `"
let delimitMate_expand_cr = 1
let delimitMate_jump_expansion = 1

if has('autocmd')
	augroup vimrc
		" filetype specific pairs
		" filetype specific quotes
		autocmd FileType vim let b:delimitMate_quotes = "'"
		" filetype specific nesting
		autocmd FileType python let b:delimitMate_nesting_quotes = ['"']
	augroup END
endif

"
" EasyMotion
"
let g:EasyMotion_enter_jump_first = 1
let g:EasyMotion_smartcase = 1
let g:EasyMotion_use_smartsign_us = 1
let g:EasyMotion_startofline = 0
let g:EasyMotion_move_highlight = 0
" replace default search
map m <plug>(easymotion-prefix)
map / <plug>(easymotion-sn)
omap / <plug>(easymotion-tn)
map n <plug>(easymotion-next)
map N <plug>(easymotion-prev)

"
" EasyTags
"
set tags=./tags;$HOME
let g:easytags_by_filetype = util#path_join(g:vimfiles_path, 'tags')
call util#mkdir_if_none(g:easytags_by_filetype)
let g:easytags_dynamic_files = 1
let g:easytags_include_members = 1
let g:easytags_updatetime_warn = 0
let g:easytags_always_enabled = 1
let g:easytags_auto_highlight = 0
let g:easytags_async = 1

"
" FSwitch
"
if has('autocmd')
	augroup vimrc
		autocmd FileType c,cpp nmap <buffer> <leader>af :FSHere<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>al :FSRight<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aL :FSSplitRight<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>ah :FSLeft<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aH :FSSplitLeft<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>ak :FSAbove<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aK :FSSplitAbove<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aj :FSBelow<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aJ :FSSplitBelow<cr>
	augroup END
endif

"
" Gundo
"
let g:gundo_help = 0
let g:gundo_preview_bottom = 1
let g:gundo_width = 60
let g:gundo_preview_height = 20
command! -nargs=0 UndoTree silent GundoToggle

"
" ListToggle
"
let g:lt_location_list_toggle_map = '<leader>l'
let g:lt_quickfix_list_toggle_map = '<leader>q'
let g:lt_height = 10

"
" Modestatus
"
call modestatus#extensions#enable('core')
call modestatus#extensions#enable('loclist')

let g:modestatus#statusline = {
		\ 'active': {
		\   'left': [
		\     'line_percent',
		\     'position',
		\     'mode',
		\     'filename',
		\     'modified',
		\     'readonly',
		\     'paste',
		\     'filetype',
		\     'encoding',
		\     'fileformat',
		\     'loclist_errors',
		\     'loclist_warnings',
		\   ],
		\   'right': [
		\   ]
		\ },
		\ 'inactive': {
		\   'left': [
		\     'filename',
		\     'modified',
		\     'readonly',
		\     'filetype',
		\     'encoding',
		\     'fileformat',
		\     'loclist_errors',
		\     'loclist_warnings'
		\   ],
		\   'right': [
		\   ]
		\ }}

if has('multi_byte') && !has('win32')
	let g:modestatus_mode_format = '‹%s›'
else
	let g:modestatus_mode_format = '<%s>'
endif

let g:modestatus#extensions#core#filename_override = {
	\   '[No Name]': '',
	\   '__Gundo__': 'Undo Tree',
	\   '__Gundo_Preview__': 'Undo Preview'
	\ }

let g:modestatus#extensions#core#filetype_override = {
	\   'qf': ''
	\ }

function! StatuslineHighlight()
	call modestatus#highlight#copymod('Statusline', 'User1', {
		\ 'term': 'bold',
		\ 'cterm': 'bold',
		\ 'gui': 'bold'})
	call modestatus#highlight#copymod('Statusline', 'User2', {
		\ 'term': 'bold',
		\ 'cterm': 'bold', 'ctermfg': 'Yellow',
		\ 'gui': 'bold', 'guifg': 'Yellow'})
	call modestatus#highlight#copymod('Statusline', 'User3', {
		\ 'term': 'bold',
		\ 'cterm': 'bold', 'ctermfg': 'Red',
		\ 'gui': 'bold', 'guifg': 'Red'})
	call modestatus#highlight#copymod('Statusline', 'User8', {
		\ 'ctermfg': 'White', 'ctermbg': '124',
		\ 'guifg': 'White', 'guibg': '#af0000'})
	call modestatus#highlight#copymod('Statusline', 'User9', {
		\ 'ctermfg': 'Black', 'ctermbg': '178',
		\ 'guifg': 'Black', 'guibg': '#dfaf00'})
endfunction

if has('autocmd')
	augroup vimrc
		autocmd VimEnter,ColorScheme * call StatuslineHighlight()
	augroup END
else
	call StatuslineHighlight()
endif

call modestatus#colors#add('bold', 1)
call modestatus#colors#add('ylw_bold', 2)
call modestatus#colors#add('red_bold', 3)
call modestatus#colors#add('error', 8)
call modestatus#colors#add('warning', 9)

call modestatus#options#add('filename', {
	\ 'active': {
	\   'color': 'bold'
	\ }})
call modestatus#options#add('mode', {
	\ 'active': {
	\   'color': 'ylw_bold',
	\   'format': g:modestatus_mode_format
	\ }})
call modestatus#options#add('modified', {
	\ 'active': {
	\   'color': 'red_bold'
	\ }})
call modestatus#options#add('readonly', {
	\ 'active': {
	\   'color': 'red_bold'
	\ }})
call modestatus#options#add('paste', {
	\ 'active': {
	\   'color': 'red_bold'
	\ }})
call modestatus#options#add('filetype', {
	\ 'active': {
	\   'format': '[%s]'
	\ },
	\ 'inactive': {
	\   'format': '[%s]'
	\ }})
call modestatus#options#add('encoding', {
	\ 'active': {
	\   'format': '[%s:',
	\   'nosep': 1
	\ },
	\ 'inactive': {
	\   'format': '[%s:',
	\   'nosep': 1
	\ }})
call modestatus#options#add('fileformat', {
	\ 'active': {
	\   'format': '%s]'
	\ },
	\ 'inactive': {
	\   'format': '%s]'
	\ }})
call modestatus#options#add('loclist_errors', {
	\ 'active': {
	\   'color': 'error',
	\   'format': ' %s ',
	\   'nosep': 1
	\ },
	\ 'inactive': {'nosep': 1}
	\ })
call modestatus#options#add('loclist_warnings', {
	\ 'active': {
	\   'color': 'warning',
	\   'format': ' %s ',
	\   'nosep': 1
	\ },
	\ 'inactive': {'nosep': 1}
	\ })

"
" Signify
"
let g:signify_disable_by_default = 0
let g:signify_sign_overwrite = 0
let g:signify_sign_add = '+'
let g:signify_sign_change = '~'
let g:signify_sign_delete = '-'
if has('multi_byte') && !has('win32')
	let g:signify_sign_delete_first_line = '‾'
else
	let g:signify_sign_delete_first_line = '^'
endif

"
" Syntastic
"
let g:syntastic_check_on_wq = 0
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 1
let g:syntastic_echo_current_error = 1
let g:syntastic_enable_signs = 0
let g:syntastic_enable_highlighting = 0
let g:syntastic_enable_balloons = 0
let g:syntastic_aggregate_errors = 1
let g:syntastic_python_checkers = ['pylint', 'flake8']
let g:syntastic_tex_checkers = ['chktex']

"
" UltiSnips
"
let g:UltiSnipsEditSplit = 'vertical'
let g:UltiSnipsExpandTrigger = '<c-j>'
let g:UltiSnipsJumpForwardTrigger = '<c-j>'
let g:UltiSnipsJumpBackwardTrigger = '<c-k>'

"
" Unite
"
if executable('ack-grep')
	let g:unite_source_grep_command = 'ack-grep'
	let g:unite_source_grep_default_opts = '--noheading --nocolor -k -H'
	let g:unite_source_grep_recursive_opt = ''
endif

let g:unite_data_directory = util#path_join(g:vimfiles_path, 'cache')
call util#mkdir_if_none(g:unite_data_directory)
let g:unite_source_session_default_session_name = 'default'
let g:unite_source_session_path = expand('~/.vim/sessions')
let g:unite_force_overwrite_statusline = 0
let g:unite_winheight = 20
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])
if has('multi_byte') && !has('win32')
	call unite#custom#profile('default', 'context', {
		\     'prompt': '» ',
		\     'silent': 1,
		\     'direction': 'botright',
		\     'prompt_direction': 'top'
		\ })
else
	call unite#custom#profile('default', 'context', {
		\     'prompt': '>> ',
		\     'silent': 1,
		\     'direction': 'botright',
		\     'prompt_direction': 'top'
		\ })
endif
call unite#custom#profile('files', 'context', {'start_insert': 1})
call unite#custom#profile('buffers', 'context', {'start_insert': 1})
call unite#custom#profile('search', 'context', {'no_quit': 1})

nnoremap <leader>f :Unite -buffer-name=files file_rec<cr>
nnoremap <leader>b :Unite -profile-name=files -buffer-name=buffers buffer<cr>
nnoremap <leader>/ :Unite -buffer-name=search grep<cr>

if has('autocmd')
	augroup vimrc
		" apply unite buffer settings
		autocmd FileType unite call s:unite_settings()
	augroup END
endif

"
" Unite Outline
"
call unite#custom#profile('outline', 'context', {'no_split': 1})
nnoremap <leader>o :Unite -buffer-name=outline outline<cr>

"
" Unite Session
"
nnoremap <leader>s :Unite -buffer-name=sessions session<cr>
command! -nargs=? LoadSession UniteSessionLoad <args>
command! -nargs=? SaveSession UniteSessionSave <args>

function! s:unite_settings()
	imap <buffer> <tab>   <Plug>(unite_choose_action)
	nmap <buffer> <tab>   <Plug>(unite_choose_action)
	imap <buffer> <s-tab> <Plug>(unite_exit)
	nmap <buffer> <s-tab> <Plug>(unite_exit)
	imap <buffer> <c-n>   <Plug>(unite_select_next_line)
	nmap <buffer> <c-n>   <Plug>(unite_select_next_line)
	imap <buffer> <c-p>   <Plug>(unite_select_previous_line)
	nmap <buffer> <c-p>   <Plug>(unite_select_previous_line)
endfunction

"
" YouCompleteMe
"
let g:ycm_global_ycm_extra_conf = util#path_join(g:vimfiles_path, 'ycm/ycm_extra_conf.py')
let g:ycm_confirm_extra_conf = 1
let g:ycm_cache_omnifunc = 1
let g:ycm_collect_identifiers_from_tags_files = 1
let g:ycm_extra_conf_c_flags = '-xc -std=c11 -Wall -Wextra'
let g:ycm_extra_conf_cpp_flags = '-xc++ -std=c++11 -Wall -Wextra'
let g:ycm_extra_conf_vim_data = [
	\   '&filetype',
	\   'g:ycm_extra_conf_c_flags',
	\   'g:ycm_extra_conf_cpp_flags'
	\]

if has('autocmd')
	augroup vimrc
		autocmd FileType c      nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType cpp    nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType objc   nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType objcpp nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType cs     nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType python nmap <buffer> <c-]> :YcmCompleter GoTo<cr>
	augroup END
endif

" --------
" Mappings
" --------
noremap  <left>  <nop>
noremap  <right> <nop>
noremap  <up>    <nop>
noremap  <down>  <nop>
cnoremap <left>  <nop>
cnoremap <right> <nop>
cnoremap <up>    <nop>
cnoremap <down>  <nop>
inoremap <left>  <nop>
inoremap <right> <nop>
inoremap <up>    <nop>
inoremap <down>  <nop>

" yank to end of line
nnoremap Y y$

" treat line wraps as real lines
nnoremap j gj
nnoremap k gk

" indent and un-indent
vnoremap > >gv
vnoremap < <gv

" visually select last edited/pasted text
nnoremap gV `[v`]

" sudo write file
cmap w!! w !sudo tee > /dev/null %

" Set tab width using a nice prompt
function! s:set_tabs()
	let l:tabstop = 1 * input('setlocal tabstop = softtabstop = shiftwidth = ')
	if l:tabstop > 0
		let &l:ts = l:tabstop
		let &l:sts = l:tabstop
		let &l:sw = l:tabstop
	endif
	let l:et = input('setlocal expandtab = ')
	if l:et == 0
		setlocal noexpandtab
	else
		setlocal expandtab
	end
	echo
	echo "\r"
	call s:summarize_tabs()
endfunction

" Summarize current tab info
function! s:summarize_tabs()
	try
		echom 'tabstop=' . &l:ts . ' softtabstop=' . &l:sts . ' shiftwidth=' . &l:sw .
					\' ' . ((&l:et) ? 'expandtab' : 'noexpandtab')
	endtry
endfunction

command! -nargs=0 SetTabs call s:set_tabs()
command! -nargs=0 SummarizeTabs call s:summarize_tabs()

" Remove trailing whitespace
function! s:strip_trailing_whitespace()
	if exists('b:no_strip_whitespace') && b:no_strip_whitespace == 1
		return
	endif

	exe 'normal mz'
	%s/\s\+$//ge
	exe 'normal `z'
endfunction

command! -nargs=0 StripTrailingWhitespace call s:strip_trailing_whitespace()
