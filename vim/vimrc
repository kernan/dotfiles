" -----
" Setup
" -----
if has('vim_starting')
	set nocompatible
	filetype off
	set runtimepath+=$HOME/.vim/bundle/neobundle
endif

let g:neobundle#enable_name_conversion = 1

call neobundle#begin(expand('~/.vim/bundle'))

NeoBundleFetch 'Shougo/neobundle.vim'

NeoBundle 'Shougo/vimproc', {
	\   'build' : {
	\     'unix'   : 'make -f make_unix.mak',
	\     'mac'    : 'make -f make_mac.mak',
	\     'cygwin' : 'make -f make_cygwin.mak',
	\     'windows': 'make -f make_mingw32.mak'
	\   }
	\ }

NeoBundle 'gist:kernan/7382226', {
	\   'name': 'neobundle_autoupdate',
	\   'script_type': 'plugin',
	\   'augroup': 'neobundle_autoupdate',
	\   'depends': ['Shougo/neobundle.vim', 'Shougo/unite.vim']
	\ }

" appearance
NeoBundle 'tomasr/molokai'
NeoBundle 'itchyny/lightline.vim'

" vcs integration
NeoBundle 'mhinz/vim-signify', {'augroup': 'signify'}

" languages
NeoBundle 'leshill/vim-json'
NeoBundle 'tikhomirov/vim-glsl'
NeoBundle 'tpope/vim-markdown'

" unite
NeoBundle 'Shougo/unite.vim'
NeoBundle 'Shougo/unite-outline', {'depends': 'Shougo/unite.vim'}
NeoBundle 'Shougo/unite-session', {'depends': 'Shougo/unite.vim'}

" other
NeoBundle 'derekwyatt/vim-fswitch'
NeoBundle 'kana/vim-textobj-entire', {'depends': 'kana/vim-textobj-user'}
NeoBundle 'Lokaltog/vim-easymotion', {'depends': 'tpope/vim-repeat'}
NeoBundle 'nelstrom/vim-visual-star-search'
NeoBundle 'Raimondi/delimitMate'
NeoBundle 'scrooloose/syntastic'
NeoBundle 'SirVer/ultisnips'
NeoBundle 'tommcdo/vim-exchange'
NeoBundle 'tpope/vim-abolish', {'depends': 'tpope/vim-repeat'}
NeoBundle 'tpope/vim-commentary', {'depends': 'tpope/vim-repeat'}
NeoBundle 'tpope/vim-endwise'
NeoBundle 'tpope/vim-surround', {'depends': 'tpope/vim-repeat'}
NeoBundle 'tpope/vim-unimpaired', {'depends': 'tpope/vim-repeat'}
NeoBundle 'Valloric/ListToggle'
NeoBundle 'Valloric/YouCompleteMe'
NeoBundle 'xolox/vim-easytags', {'depends': 'xolox/vim-misc'}

call neobundle#end()

" load matchit.vim
runtime! macros/matchit.vim

if has('autocmd')
	augroup vimrc
		autocmd!
	augroup END
endif

" --------
" Settings
" --------
function! MkdirIfNone(dir)
	if !isdirectory(a:dir)
		if exists('*mkdir')
			call mkdir(a:dir, 'p')
			echo 'created directory: ' . a:dir
		else
			echo 'cannot make directory: ' . a:dir
		endif
	endif
endfunction

call MkdirIfNone(expand('~/.vim/undo'))

filetype plugin indent on
set omnifunc=syntaxcomplete#Complete

let mapleader = "\\"
let maplocalleader = "\\"

set history=1000
set undoreload=1000
set undodir=$HOME/.vim/undo
set undofile   " enable undo files
set nobackup   " disable backup files
set noswapfile " disable swap files
set pastetoggle=<F2>
set mouse=a " enable all mouse modes
if has('unnamedplus')
	" properly handle system clipboard in x11
	set clipboard=unnamedplus,unnamed
else
	set clipboard+=unnamed
endif
set modeline
set modelines=5
set backspace=indent,eol,start
set autoread " automatically read file changes
set hidden " automatically manage hidden buffers
set ttimeoutlen=100
set timeoutlen=3000
set noerrorbells novisualbell t_vb=
set shortmess =a " use all abbreviations
set shortmess+=t " truncate file message if too long
set shortmess+=s " remove 'search hit TOP/BOTTOM' message
set shortmess+=o " file-read message overwrites file-written message
set shortmess+=O " file-read message overwrites any message
set shortmess+=I " remove intro message
set showcmd " show partial command on the last line
set ttyfast " smoother redraw with multiple windows
set lazyredraw " disable screen draw during macros
set t_ut= " clear background, fixes background in tmux
set number " show line numbers
set norelativenumber " don't use relative numbers
set laststatus=2 " always show the status bar
set noshowmode   " don't show mode
set listchars=tab:▸\ ,eol:¬,extends:»,precedes:«
set showbreak=…
set list " show hidden characters
set synmaxcol=800 " max column for syntax highlighting
set completeopt=menu,menuone,longest
set cursorline " highlight the current cursor line
set wildmenu " enable wildmenu
set wildmode=longest:full,full
set wildignore+=.hg,.git,.svn                    " version control files
set wildignore+=*.aux,*.out,*.toc                " LaTeX build files
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.class                          " java compiled objects
set wildignore+=*.luac                           " lua byte code
set wildignore+=*.pyc                            " python byte code
set wildignore+=*.sw                             " vim swap files
set wildignore+=*.DS_Store                       " OSX something
set tabstop=4     " number of spaces a tab appears as
set shiftwidth=4  " number of spaces to use for each step of (auto)indent
set softtabstop=4 " number of spaces a tab counts for while editing
set noexpandtab   " do not expand tabs to spaces
set wrap         " wrap displayed text
set textwidth=80 " wrap to 80 columns
set formatoptions=cqrnj
set smartindent " smart indent new lines
set shiftround  " round indent to multiple of shiftwidth
set cinoptions+=L-1 " indent of labels -> none
set cinoptions+=:0  " indent of cases -> none
set cinoptions+=l1  " indent of block after case -> align with case statement
set cinoptions+=g0  " indent of scope declarations -> none
set cinoptions+=N-s " indent of statements inside namespace -> none
set cinoptions+=j1  " indent Java anonymous classes correctly
set magic      " use special characters in search patterns
set ignorecase " ignore case of search term
set smartcase  " stop ignoring case when search pattern includes upper-case characters
set incsearch  " show matches as the command is being type
set hlsearch   " highlight all search results
set gdefault   " substitute all matches on a line by default
set scrolloff=3

if has('autocmd')
	augroup vimrc
		" automatically resize splits on window resize
		autocmd VimResized * :wincmd =
		" restore line position
		autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
	augroup END
endif

" -----------
" Colorscheme
" -----------
syntax on

let bundle = neobundle#get('molokai')
function! bundle.hooks.on_source(bundle)
	let g:rehash256 = 1
	set background=dark
	colorscheme molokai

	" color changes
	highlight DiffAdd                   guibg=PaleGreen guifg=bg     gui=none
	highlight DiffDelete                guibg=Tomato    guifg=bg     gui=none
	highlight DiffChange                guibg=Khaki     guifg=bg     gui=none
	highlight DiffText                  guibg=SkyBlue3  guifg=bg     gui=none
	if &t_Co > 255
		highlight DiffAdd                   ctermbg=120 ctermfg=bg  cterm=none
		highlight DiffDelete                ctermbg=202 ctermfg=bg  cterm=none
		highlight DiffChange                ctermbg=192 ctermfg=bg  cterm=none
		highlight DiffText                  ctermbg=74  ctermfg=bg  cterm=none
	endif

	" Signify colors
	highlight SignifySignAdd            guibg=#232526   guifg=Green  gui=none
	highlight SignifySignDelete         guibg=#232526   guifg=Red    gui=none
	highlight SignifySignChange         guibg=#232526   guifg=Yellow gui=none
	if &t_Co > 255
		highlight SignifySignAdd            ctermbg=235 ctermfg=28  cterm=none
		highlight SignifySignDelete         ctermbg=235 ctermfg=196 cterm=none
		highlight SignifySignChange         ctermbg=235 ctermfg=226 cterm=none
	endif

	" Syntastic colors
	highlight SyntasticErrorSign        guibg=#232526   guifg=Red    gui=none
	highlight SyntasticWarningSign      guibg=#232526   guifg=Yellow gui=none
	highlight SyntasticStyleErrorSign   guibg=#232526   guifg=Red    gui=none
	highlight SyntasticStyleWarningSign guibg=#232526   guifg=Yellow gui=none
	if &t_Co > 255
		highlight SyntasticErrorSign        ctermbg=235 ctermfg=196 cterm=none
		highlight SyntasticWarningSign      ctermbg=235 ctermfg=226 cterm=none
		highlight SyntasticStyleErrorSign   ctermbg=235 ctermfg=196 cterm=none
		highlight SyntasticStyleWarningSign ctermbg=235 ctermfg=226 cterm=none
	endif
endfunction

" -------
" Plugins
" -------
" netrw
let g:loaded_netrw = 1
let g:loaded_netrwPlugin = 1

" commentary
let bundle = neobundle#get('commentary')
function! bundle.hooks.on_source(bundle)
	if has('autocmd')
		augroup vimrc
			autocmd FileType json setlocal commentstring=%s
		augroup END
	endif
endfunction

" DelimitMate
let bundle = neobundle#get('delimitMate')
function! bundle.hooks.on_source(bundle)
	let g:delimitMate_autoclose = 1
	let g:delimitMate_matchpairs = "(:),[:],{:}"
	let g:delimitMate_smart_matchpairs = 1
	let g:delimitMate_balance_matchpairs = 1
	let g:delimitMate_quotes = "\" '"
	let g:delimitMate_smart_quotes = 1
	let g:delimitMate_expand_cr = 1
	let g:delimitMate_expand_space = 1
	let g:delimitMate_excluded_regions = "Comment"
	if has('autocmd')
		augroup vimrc
			" filetype specific quotes
			autocmd FileType vim let b:delimitMate_quotes = "'"
		augroup END
	endif
endfunction

" EasyMotion
let bundle = neobundle#get('easymotion')
function! bundle.hooks.on_source(bundle)
	let g:EasyMotion_enter_jump_first = 1
	let g:EasyMotion_smartcase = 1
	let g:EasyMotion_use_smartsign_us = 1
	let g:EasyMotion_startofline = 0
	let g:EasyMotion_move_highlight = 0
	map em <plug>(easymotion-prefix)
	" replace default search
	map / <plug>(easymotion-sn)
	omap / <plug>(easymotion-tn)
	map n <plug>(easymotion-next)
	map N <plug>(easymotion-prev)
endfunction

" EasyTags
let bundle = neobundle#get('easytags')
function! bundle.hooks.on_source(bundle)
	set tags=./tags;$HOME
	let g:easytags_dynamic_files = 1
	call MkdirIfNone(expand('~/.tags'))
	let g:easytags_by_filetype = '~/.tags'
	let g:easytags_updatetime_warn = 0
	let g:easytags_events = ['BufRead', 'BufWritePost']
	let g:easytags_always_enableds = 1
endfunction

" FSwitch
let bundle = neobundle#get('fswitch')
function! bundle.hooks.on_source(bundle)
	nmap <leader>af :FSHere<cr>
	nmap <leader>al :FSRight<cr>
	nmap <leader>aL :FSSplitRight<cr>
	nmap <leader>ah :FSLeft<cr>
	nmap <leader>aH :FSSplitLeft<cr>
	nmap <leader>ak :FSAbove<cr>
	nmap <leader>aK :FSSplitAbove<cr>
	nmap <leader>aj :FSBelow<cr>
	nmap <leader>aJ :FSSplitBelow<cr>
endfunction

" lightline
let bundle = neobundle#get('lightline')
function! bundle.hooks.on_source(bundle)
	let g:lightline = {
		\   'colorscheme': 'wombat',
		\   'mode_map': {
		\     'n':      'N',
		\     'i':      'I',
		\     'R':      'R',
		\     'v':      'V',
		\     'V':      'V',
		\     "\<c-v>": 'V',
		\     'c':      'C',
		\     's':      'S',
		\     'S':      'S',
		\     "\<c-s>": 'S',
		\     '?':      '?',
		\   },
		\   'separator': {
		\     'left': '',
		\     'right': ''
		\   },
		\   'subseparator': {
		\     'left': '›',
		\     'right': '‹'
		\   },
		\   'component_function': {
		\     'fileencoding': 'LightlineComponent_fileencoding',
		\     'fileformat':   'LightlineComponent_fileformat',
		\     'filename':     'LightlineComponent_filename',
		\     'filetype':     'LightlineComponent_filetype',
		\     'vcs':          'LightlineComponent_vcs'
		\   },
		\   'component_expand': {
		\     'loclist': 'LightlineComponent_loclist'
		\   },
		\   'component_type': {
		\     'loclist': 'error',
		\   },
		\   'active': {
		\     'left':  [['mode', 'paste'],
		\               ['vcs', 'filename', 'loclist']],
		\     'right': [['lineinfo'],
		\               ['percent'],
		\               ['fileformat', 'fileencoding', 'filetype']]
		\   },
		\   'tabline': {
		\     'left':  [['tabs']],
		\     'right': [[]]
		\   }
		\ }
	let g:lightline_hunks_symbols = ['+', '~', '-']
endfunction

function! LightlineComponent_fileencoding()
	if exists('b:lightline_show_fileencoding') && b:lightline_show_fileencoding == 1
		if winwidth(0) > 70
			return strlen(&fenc) ? &fenc : ''
		endif
	endif
	return ''
endfunction

function! LightlineComponent_fileformat()
	if exists('b:lightline_show_fileformat') && b:lightline_show_fileformat == 1
		if winwidth(0) > 70
			return strlen(&fileformat) ? &fileformat : ''
		endif
	endif
	return ''
endfunction

function! LightlineComponent_filename()
	let l:filename = expand('%:t')
	let l:filename = len(l:filename) ? l:filename : ''
	let l:readonly = &readonly ? '!! ' : ''
	let l:modified = &modified ? '+' : ''
	let l:modified = (len(l:modified) && len(l:filename) ? ' ' : '') . l:modified
	return l:readonly . l:filename . l:modified
endfunction

function! LightlineComponent_filetype()
	if exists('b:lightline_show_filetype') && b:lightline_show_filetype == 1
		if winwidth(0) > 70
			return strlen(&filetype) ? &filetype : ''
		endif
	endif
	return ''
endfunction

function! LightlineComponent_vcs()
	if g:loaded_signify == 1
		" build string of hunks
		let l:hunks = sy#repo#get_stats()
		let l:hunks_str = ''
		for i in [0, 1, 2]
			if l:hunks[i] > 0
				let l:hunks_str .= printf('%s%s', g:lightline_hunks_symbols[i], l:hunks[i])
				if i < 2 && l:hunks[i+1] > 0
					let l:hunks_str .= ' '
				endif
			endif
		endfor
		return l:hunks_str
	endif
	return ''
endfunction

function! LightlineComponent_loclist()
	" get error/warning count
	let l:loclist = getloclist(0)
	let l:num_errors = 0
	let l:num_warns = 0
	for i in l:loclist
		if i.type == 'E'
			let l:num_errors += 1
		else
			let l:num_warns += 1
		endif
	endfor
	" generate string
	let l:loclist_str = ''
	if l:num_errors > 0
		let l:loclist_str .= 'E: ' . l:num_errors
	endif
	if l:num_warns > 0
		if l:num_errors > 0
			let l:loclist_str .= ' '
		endif
		let l:loclist_str .= 'W: ' . l:num_warns
	endif
	return l:loclist_str
endfunction

" ListToggle
let bundle = neobundle#get('ListToggle')
function! bundle.hooks.on_source(bundle)
	let g:lt_location_list_toggle_map = '<leader>l'
	let g:lt_quickfix_list_toggle_map = '<leader>q'
	let g:lt_height = 10
endfunction

" NeoBundle AutoUpdate
let bundle = neobundle#get('neobundle_autoupdate')
function! bundle.hooks.on_source(bundle)
	call MkdirIfNone(expand('~/.vim/cache'))
	let g:neobundle_autoupdate_dir = expand('~/.vim/cache')
	let g:neobundle_autoupdate_time = 172800
endfunction

" Signify
let bundle = neobundle#get('signify')
function! bundle.hooks.on_source(bundle)
	let g:signify_sign_overwrite = 0
	let g:signify_sign_add = '+'
	let g:signify_sign_change = '~'
	let g:signify_sign_delete = '-'
	let g:signify_sign_delete_first_line = '^'
endfunction

" Syntastic
let bundle = neobundle#get('syntastic')
function! bundle.hooks.on_source(bundle)
	let g:syntastic_check_on_wq = 0
	let g:syntastic_always_populate_loc_list = 1
	let g:syntastic_auto_loc_list = 1
	let g:syntastic_check_on_open = 1
	let g:syntastic_echo_current_error = 1
	let g:syntastic_enable_signs = 0
	let g:syntastic_enable_highlighting = 0
	let g:syntastic_enable_balloons = 0
	let g:syntastic_error_symbol = '✕'
	let g:syntastic_style_error_symbol = '✠'
	let g:syntastic_warning_symbol = '△'
	let g:syntastic_style_warning_symbol = '≈'
	let g:syntastic_python_checkers = ['flake8']
endfunction

" UltiSnips
let bundle = neobundle#get('ultisnips')
function! bundle.hooks.on_source(bundle)
	let g:UltiSnipsEditSplit = 'vertical'
	let g:UltiSnipsSnippetDirectories = ['snips']
	let g:UltiSnipsExpandTrigger = '<c-j>'
	let g:UltiSnipsJumpForwardTrigger = '<c-j>'
	let g:UltiSnipsJumpBackwardTrigger = '<c-k>'
endfunction

" Unimpaired
let bundle = neobundle#get('unimpaired')
function! bundle.hooks.on_source(bundle)
	nmap mk [e
	nmap mj ]e
	vmap mk [egv
	vmap mj ]egv
endfunction

" Unite
let bundle = neobundle#get('unite')
function! bundle.hooks.on_source(bundle)
	if executable('ack-grep')
		let g:unite_source_grep_command = 'ack-grep'
		let g:unite_source_grep_default_opts = '--noheading --nocolor -k -H'
		let g:unite_source_grep_recursive_opt = ''
	endif

	let g:unite_data_directory = expand('~/.vim/cache')
	let g:unite_source_session_default_session_name = 'default'
	let g:unite_source_session_path = expand('~/.vim/sessions')
	let g:unite_force_overwrite_statusline = 0
	let g:unite_winheight = 20
	call unite#filters#matcher_default#use(['matcher_fuzzy'])
	call unite#filters#sorter_default#use(['sorter_rank'])
	call unite#custom#profile('default', 'context', {
		\     'prompt': '» ',
		\     'silent': 1,
		\     'direction': 'botright',
		\     'prompt_direction': 'top'
		\ })
	call unite#custom#profile('files', 'context', {'start_insert': 1})
	call unite#custom#profile('buffers', 'context', {'start_insert': 1})
	call unite#custom#profile('search', 'context', {'no_quit': 1})

	nnoremap <leader>f :Unite -buffer-name=files file_rec/async<cr>
	nnoremap <leader>b :Unite -profile-name=files -buffer-name=buffers buffer<cr>
	nnoremap <leader>/ :Unite -buffer-name=search grep<cr>
endfunction

let bundle = neobundle#get('unite-session')
function! bundle.hooks.on_source(bundle)
	nnoremap <leader>s :Unite -buffer-name=sessions session<cr>
	command! -nargs=? LoadSession UniteSessionLoad <args>
	command! -nargs=? SaveSession UniteSessionSave <args>
endfunction

let bundle = neobundle#get('unite-outline')
function! bundle.hooks.on_source(bundle)
	call unite#custom#profile('outline', 'context', {'no_split': 1})
	nnoremap <leader>o :Unite -buffer-name=outline outline<cr>
endfunction

function! UniteBufferSettings()
	imap <buffer> <tab>   <Plug>(unite_choose_action)
	nmap <buffer> <tab>   <Plug>(unite_choose_action)
	imap <buffer> <s-tab> <Plug>(unite_exit)
	nmap <buffer> <s-tab> <Plug>(unite_exit)
	imap <buffer> <c-n>   <Plug>(unite_select_next_line)
	nmap <buffer> <c-n>   <Plug>(unite_select_next_line)
	imap <buffer> <c-p>   <Plug>(unite_select_previous_line)
	nmap <buffer> <c-p>   <Plug>(unite_select_previous_line)
endfunction

if has('autocmd')
	augroup vimrc
		" apply unite buffer settings
		autocmd FileType unite call UniteBufferSettings()
	augroup END
endif

" YouCompleteMe
let bundle = neobundle#get('YouCompleteMe')
function! bundle.hooks.on_source(bundle)
	let g:ycm_global_ycm_extra_conf = expand('~/.vim/ycm/ycm_extra_conf.py')
	let g:ycm_confirm_extra_conf = 1
	let g:ycm_cache_omnifunc = 1
	let g:ycm_collect_identifiers_from_tags_files = 1
	let g:ycm_extra_conf_c_flags = '-xc -std=c11 -Wall -Wextra'
	let g:ycm_extra_conf_cpp_flags = '-xc++ -std=c++11 -Wall -Wextra'
	let g:ycm_extra_conf_vim_data = [
				\   '&filetype',
				\   'g:ycm_extra_conf_c_flags',
				\   'g:ycm_extra_conf_cpp_flags'
				\]
endfunction

" --------
" Mappings
" --------
noremap  <left>  <nop>
noremap  <right> <nop>
noremap  <up>    <nop>
noremap  <down>  <nop>
cnoremap <left>  <nop>
cnoremap <right> <nop>
cnoremap <up>    <nop>
cnoremap <down>  <nop>
inoremap <left>  <nop>
inoremap <right> <nop>
inoremap <up>    <nop>
inoremap <down>  <nop>

" treat line wraps as real lines
nnoremap j gj
nnoremap k gk

" indent and un-indent
vnoremap > >gv
vnoremap < <gv

" visually select last edited/pasted text
nnoremap gV `[v`]

" sudo write file
cmap w!! w !sudo tee > /dev/null %

" Set tab width using a nice prompt
function! SetTab()
	let l:tabstop = 1 * input('setlocal tabstop = softtabstop = shiftwidth = ')
	if l:tabstop > 0
		let &l:tw = l:tabstop
		let &l:sts = l:tabstop
		let &l:sw = l:tabstop
	endif
	let l:et = input('setlocal expandtab = ')
	if l:et == 0
		setlocal noexpandtab
	else
		setlocal expandtab
	end
	echo
	echo "\r"
	call SummarizeTabs()
endfunction

" Summarize current tab info
function! SummarizeTabs()
	try
		echom 'tabstop=' . &l:ts . ' softtabstop=' . &l:sts . ' shiftwidth=' . &l:sw .
					\' ' . ((&l:et) ? 'expandtab' : 'noexpandtab')
	endtry
endfunction

command! -nargs=0 SetTab call SetTab()
command! -nargs=0 SummarizeTabs call SummarizeTabs()

" Remove trailing whitespace
function! RemoveTrailingWhitespace()
	if exists('b:no_strip_whitespace') && b:no_strip_whitespace == 1
		return
	endif

	exe 'normal mz'
	%s/\s\+$//ge
	exe 'normal `z'
endfunction

if has('autocmd')
	augroup vimrc
		autocmd BufWritePre * :call RemoveTrailingWhitespace()
	augroup END
endif

" check for plugin updates
NeoBundleCheck

" apply loaded plugin settings
call neobundle#call_hook('on_source')
