scriptencoding utf-8

" -----
" Setup
" -----
if has('vim_starting')
	set nocompatible
	filetype off
	if has('win32')
		set runtimepath+=$HOME/vimfiles/bundle/Vundle.vim
		let g:bundle_path = '~/vimfiles/bundle'
	else
		set runtimepath+=$HOME/.vim/bundle/Vundle.vim
		let g:bundle_path = '~/.vim/bundle'
	endif
endif

call vundle#begin(g:bundle_path)

Plugin 'gmarik/Vundle.vim'

" appearance
Plugin 'chriskempson/base16-vim'
Plugin 'itchyny/lightline.vim'

" vcs integration
Plugin 'mhinz/vim-signify'

" languages
Plugin 'leshill/vim-json'
Plugin 'tikhomirov/vim-glsl'
Plugin 'tpope/vim-markdown'

" unite
Plugin 'Shougo/unite.vim'
Plugin 'Shougo/unite-outline', {'depends': 'Shougo/unite.vim'}
Plugin 'Shougo/unite-session', {'depends': 'Shougo/unite.vim'}

" other
Plugin 'derekwyatt/vim-fswitch'
Plugin 'kana/vim-textobj-entire', {'depends': 'kana/vim-textobj-user'}
Plugin 'Lokaltog/vim-easymotion', {'depends': 'tpope/vim-repeat'}
Plugin 'nelstrom/vim-visual-star-search'
Plugin 'Raimondi/delimitMate'
Plugin 'scrooloose/syntastic'
if has('python')
	Plugin 'SirVer/ultisnips'
endif
Plugin 'tommcdo/vim-exchange'
Plugin 'tpope/vim-abolish', {'depends': 'tpope/vim-repeat'}
Plugin 'tpope/vim-commentary', {'depends': 'tpope/vim-repeat'}
Plugin 'tpope/vim-endwise'
Plugin 'tpope/vim-surround', {'depends': 'tpope/vim-repeat'}
Plugin 'tpope/vim-unimpaired', {'depends': 'tpope/vim-repeat'}
Plugin 'Valloric/ListToggle'
if has('unix')
	Plugin 'Valloric/YouCompleteMe'
	Plugin 'xolox/vim-easytags', {'depends': 'xolox/vim-misc'}
endif

" Dependencies, TODO Remove once implemented in vundle.
Plugin 'kana/vim-textobj-user'
Plugin 'tpope/vim-repeat'
Plugin 'xolox/vim-misc'

call vundle#end()

" load matchit.vim
runtime! macros/matchit.vim

if has('autocmd')
	augroup vimrc
		autocmd!
	augroup END
endif

" --------
" Settings
" --------
function! MkdirIfNone(dir)
	if !isdirectory(a:dir)
		if exists('*mkdir')
			call mkdir(a:dir, 'p')
			echo 'created directory: ' . a:dir
		else
			echo 'cannot make directory: ' . a:dir
		endif
	endif
endfunction

call MkdirIfNone(expand('~/.vim/undo'))

filetype plugin indent on

set omnifunc=syntaxcomplete#Complete
set completeopt=menu,menuone,longest

let mapleader = "\\"
let maplocalleader = "\\"
map <space> <leader>

set history=1000
set undoreload=1000
set undodir=$HOME/.vim/undo
set undofile
set nobackup
set noswapfile

set pastetoggle=<F2>

if has('mouse')
	set mouse=a
endif

if has('unnamedplus')
	set clipboard=unnamedplus,unnamed
else
	set clipboard+=unnamed
endif

set backspace=indent,eol,start

set autoread
set hidden

set ttimeout
set ttimeoutlen=100

set noerrorbells novisualbell t_vb=
set shortmess=atsoOI
set showcmd
set scrolloff=3
set ttyfast
set lazyredraw
set t_ut=
set noshowmode
set laststatus=2
set number
set norelativenumber

if has('multi_byte')
	set listchars=tab:▸\ ,eol:¬,extends:»,precedes:«
	set showbreak=…
else
	set listchars=tab:>\ ,eol:$,extends:>,precedes:<
	set showbreak=~
endif

set list

set wildmenu
set wildmode=longest:full,full
set wildignore+=.hg,.git,.svn                    " version control files
set wildignore+=*.aux,*.out,*.toc                " LaTeX build files
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.class                          " java compiled objects
set wildignore+=*.luac                           " lua byte code
set wildignore+=*.pyc                            " python byte code
set wildignore+=*.sw                             " vim swap files
set wildignore+=*.DS_Store                       " OSX something

set tabstop=4
set shiftwidth=4
set softtabstop=4
set noexpandtab
set shiftround

set wrap
set textwidth=79
set formatoptions=cqrn1j
set smartindent

set magic
set ignorecase
set smartcase
set incsearch
set hlsearch
set gdefault

if has('autocmd')
	augroup vimrc
		" automatically resize splits on window resize
		autocmd VimResized * :wincmd =
		" restore line position
		autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
	augroup END
endif

" -----------
" Colorscheme
" -----------
syntax on

set cursorline
let g:base16colorspace=256
set background=dark
colorscheme base16-monokai

" -------
" Plugins
" -------
"
" netrw
"
let g:loaded_netrw = 1
let g:loaded_netrwPlugin = 1

"
" commentary
"
if has('autocmd')
	augroup vimrc
		autocmd FileType json setlocal commentstring=%s
	augroup END
endif

"
" DelimitMate
"
let g:delimitMate_autoclose = 1
let g:delimitMate_matchpairs = "(:),[:],{:}"
let g:delimitMate_smart_matchpairs = 1
let g:delimitMate_balance_matchpairs = 1
let g:delimitMate_quotes = "\" '"
let g:delimitMate_smart_quotes = 1
let g:delimitMate_expand_cr = 1
let g:delimitMate_expand_space = 1
let g:delimitMate_excluded_regions = "Comment"
if has('autocmd')
	augroup vimrc
		" filetype specific quotes
		autocmd FileType vim let b:delimitMate_quotes = "'"
	augroup END
endif

"
" EasyMotion
"
let g:EasyMotion_enter_jump_first = 1
let g:EasyMotion_smartcase = 1
let g:EasyMotion_use_smartsign_us = 1
let g:EasyMotion_startofline = 0
let g:EasyMotion_move_highlight = 0
map em <plug>(easymotion-prefix)
" replace default search
map / <plug>(easymotion-sn)
omap / <plug>(easymotion-tn)
map n <plug>(easymotion-next)
map N <plug>(easymotion-prev)

"
" EasyTags
"
set tags=./tags;$HOME
let g:easytags_dynamic_files = 1
call MkdirIfNone(expand('~/.tags'))
let g:easytags_by_filetype = '~/.tags'
let g:easytags_updatetime_warn = 0
let g:easytags_events = ['BufRead', 'BufWritePost']
let g:easytags_always_enableds = 1

"
" FSwitch
"
if has('autocmd')
	augroup vimrc
		autocmd FileType c,cpp nmap <buffer> <leader>af :FSHere<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>al :FSRight<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aL :FSSplitRight<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>ah :FSLeft<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aH :FSSplitLeft<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>ak :FSAbove<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aK :FSSplitAbove<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aj :FSBelow<cr>
		autocmd FileType c,cpp nmap <buffer> <leader>aJ :FSSplitBelow<cr>
	augroup END
endif

"
" lightline
"
let g:lightline = {
	\   'colorscheme': 'wombat',
	\   'mode_map': {
	\     'n':      'N',
	\     'i':      'I',
	\     'R':      'R',
	\     'v':      'V',
	\     'V':      'V',
	\     "\<c-v>": 'V',
	\     'c':      'C',
	\     's':      'S',
	\     'S':      'S',
	\     "\<c-s>": 'S',
	\     '?':      '?',
	\   },
	\   'separator': {
	\     'left': '',
	\     'right': ''
	\   },
	\   'component_function': {
	\     'fileencoding': 'LightlineComponent_fileencoding',
	\     'fileformat':   'LightlineComponent_fileformat',
	\     'filename':     'LightlineComponent_filename',
	\     'filetype':     'LightlineComponent_filetype',
	\     'vcs':          'LightlineComponent_vcs'
	\   },
	\   'component_expand': {
	\     'loclist': 'LightlineComponent_loclist'
	\   },
	\   'component_type': {
	\     'loclist': 'error',
	\   },
	\   'active': {
	\     'left':  [['mode', 'paste'],
	\               ['vcs', 'filename', 'loclist']],
	\     'right': [['lineinfo'],
	\               ['percent'],
	\               ['fileformat', 'fileencoding', 'filetype']]
	\   },
	\   'tabline': {
	\     'left':  [['tabs']],
	\     'right': [[]]
	\   }
	\ }

if has('multi_byte')
	if has('win32') " FIXME Windows doesn't display some unicode characters correctly.
		let g:lightline.subseparator = {'left': '>', 'right': '<'}
	else
		let g:lightline.subseparator = {'left': '›', 'right': '‹'}
	endif
else
	let g:lightline.subseparator = {'left': '>', 'right': '<'}
endif

let g:lightline_hunks_symbols = ['+', '~', '-']

function! LightlineComponent_fileencoding()
	if winwidth(0) > 70
		return strlen(&fenc) ? &fenc : ''
	endif
	return ''
endfunction

function! LightlineComponent_fileformat()
	if winwidth(0) > 70
		return strlen(&fileformat) ? &fileformat : ''
	endif
	return ''
endfunction

function! LightlineComponent_filename()
	let l:filename = expand('%:t')
	let l:filename = len(l:filename) ? l:filename : ''
	let l:readonly = &readonly ? '!! ' : ''
	let l:modified = &modified ? '+' : ''
	let l:modified = (len(l:modified) && len(l:filename) ? ' ' : '') . l:modified
	return l:readonly . l:filename . l:modified
endfunction

function! LightlineComponent_filetype()
	if winwidth(0) > 70
		return strlen(&filetype) ? &filetype : ''
	endif
	return ''
endfunction

function! LightlineComponent_vcs()
	if g:loaded_signify == 1
		" build string of hunks
		let l:hunks = sy#repo#get_stats()
		let l:hunks_str = ''
		for i in [0, 1, 2]
			if l:hunks[i] > 0
				let l:hunks_str .= printf('%s%s', g:lightline_hunks_symbols[i], l:hunks[i])
				if i < 2 && l:hunks[i+1] > 0
					let l:hunks_str .= ' '
				endif
			endif
		endfor
		return l:hunks_str
	endif
	return ''
endfunction

function! LightlineComponent_loclist()
	" get error/warning count
	let l:loclist = getloclist(0)
	let l:num_errors = 0
	let l:num_warns = 0
	for i in l:loclist
		if i.type == 'E'
			let l:num_errors += 1
		else
			let l:num_warns += 1
		endif
	endfor
	" generate string
	let l:loclist_str = ''
	if l:num_errors > 0
		let l:loclist_str .= 'E: ' . l:num_errors
	endif
	if l:num_warns > 0
		if l:num_errors > 0
			let l:loclist_str .= ' '
		endif
		let l:loclist_str .= 'W: ' . l:num_warns
	endif
	return l:loclist_str
endfunction

"
" ListToggle
"
let g:lt_location_list_toggle_map = '<leader>l'
let g:lt_quickfix_list_toggle_map = '<leader>q'
let g:lt_height = 10

"
" Plugin AutoUpdate
"
call MkdirIfNone(expand('~/.vim/cache'))
let g:neobundle_autoupdate_dir = expand('~/.vim/cache')
let g:neobundle_autoupdate_time = 172800

"
" Signify
"
let g:signify_sign_overwrite = 0
let g:signify_sign_add = '+'
let g:signify_sign_change = '~'
let g:signify_sign_delete = '-'
let g:signify_sign_delete_first_line = '^'

"
" Syntastic
"
let g:syntastic_check_on_wq = 0
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_echo_current_error = 1
let g:syntastic_enable_signs = 0
let g:syntastic_enable_highlighting = 0
let g:syntastic_enable_balloons = 0
if executable('flake8')
	let g:syntastic_python_checkers = ['flake8']
endif

"
" UltiSnips
"
let g:UltiSnipsEditSplit = 'vertical'
let g:UltiSnipsSnippetDirectories = ['snips']
let g:UltiSnipsExpandTrigger = '<c-j>'
let g:UltiSnipsJumpForwardTrigger = '<c-j>'
let g:UltiSnipsJumpBackwardTrigger = '<c-k>'

"
" Unimpaired
"
nmap mk [e
nmap mj ]e
vmap mk [egv
vmap mj ]egv

"
" Unite
"
if executable('ack-grep')
	let g:unite_source_grep_command = 'ack-grep'
	let g:unite_source_grep_default_opts = '--noheading --nocolor -k -H'
	let g:unite_source_grep_recursive_opt = ''
endif

let g:unite_data_directory = expand('~/.vim/cache')
let g:unite_source_session_default_session_name = 'default'
let g:unite_source_session_path = expand('~/.vim/sessions')
let g:unite_force_overwrite_statusline = 0
let g:unite_winheight = 20
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])
if has('multi_byte')
	call unite#custom#profile('default', 'context', {
		\     'prompt': '» ',
		\     'silent': 1,
		\     'direction': 'botright',
		\     'prompt_direction': 'top'
		\ })
else
	call unite#custom#profile('default', 'context', {
		\     'prompt': '>> ',
		\     'silent': 1,
		\     'direction': 'botright',
		\     'prompt_direction': 'top'
		\ })
endif
call unite#custom#profile('files', 'context', {'start_insert': 1})
call unite#custom#profile('buffers', 'context', {'start_insert': 1})
call unite#custom#profile('search', 'context', {'no_quit': 1})

nnoremap <leader>f :Unite -buffer-name=files file_rec<cr>
nnoremap <leader>b :Unite -profile-name=files -buffer-name=buffers buffer<cr>
nnoremap <leader>/ :Unite -buffer-name=search grep<cr>

nnoremap <leader>s :Unite -buffer-name=sessions session<cr>
command! -nargs=? LoadSession UniteSessionLoad <args>
command! -nargs=? SaveSession UniteSessionSave <args>

call unite#custom#profile('outline', 'context', {'no_split': 1})
nnoremap <leader>o :Unite -buffer-name=outline outline<cr>

function! UniteBufferSettings()
	imap <buffer> <tab>   <Plug>(unite_choose_action)
	nmap <buffer> <tab>   <Plug>(unite_choose_action)
	imap <buffer> <s-tab> <Plug>(unite_exit)
	nmap <buffer> <s-tab> <Plug>(unite_exit)
	imap <buffer> <c-n>   <Plug>(unite_select_next_line)
	nmap <buffer> <c-n>   <Plug>(unite_select_next_line)
	imap <buffer> <c-p>   <Plug>(unite_select_previous_line)
	nmap <buffer> <c-p>   <Plug>(unite_select_previous_line)
endfunction

if has('autocmd')
	augroup vimrc
		" apply unite buffer settings
		autocmd FileType unite call UniteBufferSettings()
	augroup END
endif

"
" YouCompleteMe
"
let g:ycm_global_ycm_extra_conf = expand('~/.vim/ycm/ycm_extra_conf.py')
let g:ycm_confirm_extra_conf = 1
let g:ycm_cache_omnifunc = 1
let g:ycm_collect_identifiers_from_tags_files = 1
let g:ycm_extra_conf_c_flags = '-xc -std=c11 -Wall -Wextra'
let g:ycm_extra_conf_cpp_flags = '-xc++ -std=c++11 -Wall -Wextra'
let g:ycm_extra_conf_vim_data = [
			\   '&filetype',
			\   'g:ycm_extra_conf_c_flags',
			\   'g:ycm_extra_conf_cpp_flags'
			\]

if has('autocmd')
	augroup vimrc
		autocmd FileType c      nnoremap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType cpp    nnoremap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType objc   nnoremap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType objcpp nnoremap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType cs     nnoremap <buffer> <c-]> :YcmCompleter GoTo<cr>
		autocmd FileType python nnoremap <buffer> <c-]> :YcmCompleter GoTo<cr>
	augroup END
endif

" --------
" Mappings
" --------
noremap  <left>  <nop>
noremap  <right> <nop>
noremap  <up>    <nop>
noremap  <down>  <nop>
cnoremap <left>  <nop>
cnoremap <right> <nop>
cnoremap <up>    <nop>
cnoremap <down>  <nop>
inoremap <left>  <nop>
inoremap <right> <nop>
inoremap <up>    <nop>
inoremap <down>  <nop>

" yank to end of line
nnoremap Y y$

" treat line wraps as real lines
nnoremap j gj
nnoremap k gk

" indent and un-indent
vnoremap > >gv
vnoremap < <gv

" visually select last edited/pasted text
nnoremap gV `[v`]

" sudo write file
cmap w!! w !sudo tee > /dev/null %

" Set tab width using a nice prompt
function! SetTab()
	let l:tabstop = 1 * input('setlocal tabstop = softtabstop = shiftwidth = ')
	if l:tabstop > 0
		let &l:tw = l:tabstop
		let &l:sts = l:tabstop
		let &l:sw = l:tabstop
	endif
	let l:et = input('setlocal expandtab = ')
	if l:et == 0
		setlocal noexpandtab
	else
		setlocal expandtab
	end
	echo
	echo "\r"
	call SummarizeTabs()
endfunction

" Summarize current tab info
function! SummarizeTabs()
	try
		echom 'tabstop=' . &l:ts . ' softtabstop=' . &l:sts . ' shiftwidth=' . &l:sw .
					\' ' . ((&l:et) ? 'expandtab' : 'noexpandtab')
	endtry
endfunction

command! -nargs=0 SetTab call SetTab()
command! -nargs=0 SummarizeTabs call SummarizeTabs()

" Remove trailing whitespace
function! RemoveTrailingWhitespace()
	if exists('b:no_strip_whitespace') && b:no_strip_whitespace == 1
		return
	endif

	exe 'normal mz'
	%s/\s\+$//ge
	exe 'normal `z'
endfunction

if has('autocmd')
	augroup vimrc
		autocmd BufWritePre * :call RemoveTrailingWhitespace()
	augroup END
endif
